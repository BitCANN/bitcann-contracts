{
  "contractName": "IllegalRegistration",
  "constructorInputs": [
    {
      "name": "registryContractScriptHash",
      "type": "bytes"
    },
    {
      "name": "domainContractPartialBytecodeHash",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "call",
      "inputs": [
        {
          "name": "domainContractPartialBytecode",
          "type": "bytes"
        },
        {
          "name": "name",
          "type": "bytes"
        }
      ]
    }
  ],
  "bytecode": "OP_TXINPUTCOUNT OP_5 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_4 OP_NUMEQUALVERIFY OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_2 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_2 OP_PICK OP_EQUALVERIFY 00 OP_EQUALVERIFY OP_3 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_2 OP_PICK OP_EQUALVERIFY OP_1 OP_EQUALVERIFY OP_2 OP_UTXOTOKENCOMMITMENT OP_8 OP_SPLIT OP_NIP OP_4 OP_ROLL OP_HASH256 OP_OVER OP_EQUALVERIFY OP_2 OP_UTXOTOKENCOMMITMENT OP_8 OP_SPLIT OP_DROP OP_3 OP_UTXOTOKENCOMMITMENT OP_8 OP_SPLIT OP_DROP OP_OVER OP_EQUALVERIFY OP_4 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_4 OP_PICK OP_EQUALVERIFY OP_1 OP_EQUALVERIFY OP_4 OP_UTXOTOKENCOMMITMENT OP_8 OP_SPLIT OP_DROP OP_BIN2NUM OP_SWAP OP_BIN2NUM OP_LESSTHAN OP_VERIFY OP_4 OP_UTXOTOKENCOMMITMENT OP_2 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY OP_4 OP_UTXOBYTECODE OP_2 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_4 OP_UTXOTOKENCATEGORY OP_2 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_4 OP_UTXOVALUE OP_2 OP_OUTPUTVALUE OP_NUMEQUALVERIFY OP_3 OP_PICK OP_HASH160 OP_3 OP_ROLL OP_EQUALVERIFY 20 OP_ROT OP_CAT 20 OP_CAT OP_SWAP OP_CAT OP_SWAP OP_CAT OP_HASH256 aa20 OP_SWAP OP_CAT 87 OP_CAT OP_4 OP_UTXOBYTECODE OP_EQUAL",
  "source": "pragma cashscript ^0.11.0;\n\ncontract IllegalRegistration(bytes registryContractScriptHash, bytes domainContractPartialBytecodeHash) {\n  /**\n   * Penalizes illegal domain registrations by allowing anyone to burn the bid and claim the funds as reward.\n   * \n   * If someone attempts to register a domain that is already owned and active (has a valid heartbeat NFT),\n   * this function allows anyone to:\n   * - Prove the domain is already owned by providing the heartbeat NFT\n   * - Burn the illegal registration bid NFTs\n   * - Claim the bid funds as a reward\n   * \n   * @param domainContractPartialBytecode - Partial bytecode of the domain contract to verify ownership\n   * @param name - Name being registered illegally\n   * \n   * @inputs\n   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract\n   * - Input1: Any input from this contract\n   * - Input2: Registration NFT pair0\n   * - Input3: Registration NFT pair1\n   * - Input4: Heartbeat NFT proving active domain ownership\n   * \n   * @outputs\n   * - Output0: Registry Contract's immutable NFT back to the Registry contract\n   * - Output1: Input1 back to this contract without any change\n   * - Output2: Heartbeat NFT back to domain contract\n   * - Output3: Bid funds to caller as reward\n   * \n   * Requirements:\n   * - Name must match stored nameHash\n   * - Heartbeat must be less than 2 years old (105120 blocks)\n   * - Domain contract bytecode must match expected hash\n   * - Heartbeat NFT must be from valid domain contract\n   * - All NFTs must have correct categories and capabilities\n   */\n  function call(bytes domainContractPartialBytecode, bytes name){\n    require(tx.inputs.length == 5);\n    require(tx.outputs.length == 4);\n    // Lock this contract to only be used with the registry contract.\n    require(tx.inputs[0].lockingBytecode == registryContractScriptHash);\n    // All the input and output conditions for inputs[0], inputs[1], outputs[0] and outputs[1] are already checked in the registry contract.\n\n    // All the token categories in the transaction should be the same.\n    bytes domainCategory = tx.outputs[0].tokenCategory.split(32)[0];\n\n    bytes pair0Category, bytes pair0Capability = tx.inputs[2].tokenCategory.split(32);\n    require(pair0Category == domainCategory);\n    require(pair0Capability == 0x00); // Immutable\n\n    bytes pair1Category, bytes pair1Capability = tx.inputs[3].tokenCategory.split(32);\n    require(pair1Category == domainCategory);\n    require(pair1Capability == 0x01); // Mutable\n\n    bytes nameHash = tx.inputs[2].nftCommitment.split(8)[1];\n    // Make sure that the name is correct.\n    require(hash256(name) == nameHash);\n\n    bytes registrationIdPart0 = tx.inputs[2].nftCommitment.split(8)[0];\n    bytes registrationIdPart1 = tx.inputs[3].nftCommitment.split(8)[0];\n    require(registrationIdPart0 == registrationIdPart1);\n\n    // Make sure that the heartbeat NFT is from the same category and in mutable capability.\n    bytes heartbeatCategory, bytes heartbeatCapability = tx.inputs[4].tokenCategory.split(32);\n    require(heartbeatCategory == domainCategory);\n    require(heartbeatCapability == 0x01); // Mutable\n\n    bytes registrationIdHeartBeat = tx.inputs[4].nftCommitment.split(8)[0];\n\n    // Make sure that registrationId in the heartbeat is less that the registrationId in the new auction.\n    require(int(registrationIdHeartBeat) < int(registrationIdPart0));\n   \n    // NOTICE: It does not matter if the heartbeat is already older than 2 years. If it is then is should be burned\n    // As it is allowed for anyone to burn the heartbeat NFT by anyone for any Domain contract is the domain has expired.\n\n    // Send the heartbeat NFT back to the domain contract.\n    require(tx.inputs[4].nftCommitment == tx.outputs[2].nftCommitment);\n    require(tx.inputs[4].lockingBytecode == tx.outputs[2].lockingBytecode);\n    require(tx.inputs[4].tokenCategory == tx.outputs[2].tokenCategory);\n    require(tx.inputs[4].value == tx.outputs[2].value);\n\n    // Derive the locking bytecode from the domain contract bytecode using the provided bytecode,\n    // provided name and the nameHash.\n\n    bytes bytecodeHash = hash160(domainContractPartialBytecode);\n    require(bytecodeHash == domainContractPartialBytecodeHash);\n    bytes domainBytecode = 0x20 + domainCategory + 0x20 + nameHash + domainContractPartialBytecode;\n    bytes32 scriptHash = hash256(domainBytecode);\n    bytes35 domainLockingBytecode = new LockingBytecodeP2SH32(scriptHash);\n\n    require(tx.inputs[4].lockingBytecode == domainLockingBytecode);\n  }\n}",
  "debug": {
    "bytecode": "c3559c69c4549c6900c7517a876900d101207f7552ce01207f517a52798769007a0100876953ce01207f517a52798769007a51876952cf587f77547aaa5179876952cf587f7553cf587f755179517a876954ce01207f517a54798769007a51876954cf587f75007a81517a819f6954cf52d2876954c752cd876954ce52d1876954c652cc9c695379a9007a537a87690120527a7e01207e517a7e517a7e007aaa02aa20517a7e01877e54c7517a87",
    "sourceMap": "37:12:37:28;:32::33;:12:::1;:4::35;38:12:38:29:0;:33::34;:12:::1;:4::36;40:22:40:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;44:38:44:39:0;:27::54:1;:61::63:0;:27::64:1;:::67;46:59:46:60:0;:49::75:1;:82::84:0;:49::85:1;47:12:47:25:0;;:29::43;;:12:::1;:4::45;48:12:48:27:0;;:31::35;:12:::1;:4::37;50:59:50:60:0;:49::75:1;:82::84:0;:49::85:1;51:12:51:25:0;;:29::43;;:12:::1;:4::45;52:12:52:27:0;;:31::35;:12:::1;:4::37;54:31:54:32:0;:21::47:1;:54::55:0;:21::56:1;:::59;56:20:56:24:0;;:12::25:1;:29::37:0;;:12:::1;:4::39;58:42:58:43:0;:32::58:1;:65::66:0;:32::67:1;:::70;59:42:59:43:0;:32::58:1;:65::66:0;:32::67:1;:::70;60:12:60:31:0;;:35::54;;:12:::1;:4::56;63:67:63:68:0;:57::83:1;:90::92:0;:57::93:1;64:12:64:29:0;;:33::47;;:12:::1;:4::49;65:12:65:31:0;;:35::39;:12:::1;:4::41;67:46:67:47:0;:36::62:1;:69::70:0;:36::71:1;:::74;70:16:70:39:0;;:12::40:1;:47::66:0;;:43::67:1;:12;:4::69;76:22:76:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;77:22:77:23:0;:12::40:1;:55::56:0;:44::73:1;:12;:4::75;78:22:78:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;79:22:79:23:0;:12::30:1;:45::46:0;:34::53:1;:12;:4::55;84:33:84:62:0;;:25::63:1;85:12:85:24:0;;:28::61;;:12:::1;:4::63;86:27:86:31:0;:34::48;;:27:::1;:51::55:0;:27:::1;:58::66:0;;:27:::1;:69::98:0;;:27:::1;87:33:87:47:0;;:25::48:1;88:36:88:73:0;:62::72;;:36::73:1;;;90:22:90:23:0;:12::40:1;:44::65:0;;:12:::1",
    "logs": [],
    "requires": [
      {
        "ip": 5,
        "line": 37
      },
      {
        "ip": 9,
        "line": 38
      },
      {
        "ip": 15,
        "line": 40
      },
      {
        "ip": 30,
        "line": 47
      },
      {
        "ip": 35,
        "line": 48
      },
      {
        "ip": 45,
        "line": 51
      },
      {
        "ip": 50,
        "line": 52
      },
      {
        "ip": 62,
        "line": 56
      },
      {
        "ip": 78,
        "line": 60
      },
      {
        "ip": 88,
        "line": 64
      },
      {
        "ip": 93,
        "line": 65
      },
      {
        "ip": 106,
        "line": 70
      },
      {
        "ip": 112,
        "line": 76
      },
      {
        "ip": 118,
        "line": 77
      },
      {
        "ip": 124,
        "line": 78
      },
      {
        "ip": 130,
        "line": 79
      },
      {
        "ip": 139,
        "line": 85
      },
      {
        "ip": 166,
        "line": 90
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.11.0-next.0"
  },
  "updatedAt": "2025-02-02T20:04:08.353Z"
}