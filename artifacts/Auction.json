{
  "contractName": "Auction",
  "constructorInputs": [
    {
      "name": "registryContractScriptHash",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "withdraw",
      "inputs": [
        {
          "name": "signature",
          "type": "sig"
        },
        {
          "name": "pk",
          "type": "pubkey"
        }
      ]
    },
    {
      "name": "start",
      "inputs": [
        {
          "name": "name",
          "type": "bytes"
        }
      ]
    },
    {
      "name": "bid",
      "inputs": []
    }
  ],
  "bytecode": "OP_OVER OP_0 OP_NUMEQUAL OP_IF OP_2SWAP OP_SWAP OP_CHECKSIG OP_NIP OP_NIP OP_ELSE OP_OVER OP_1 OP_NUMEQUAL OP_IF OP_TXINPUTCOUNT OP_4 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_6 OP_LESSTHANOREQUAL OP_VERIFY OP_0 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_2 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_2 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_3 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_2 OP_UTXOTOKENCOMMITMENT OP_REVERSEBYTES OP_BIN2NUM OP_2 OP_OUTPUTTOKENCOMMITMENT OP_REVERSEBYTES OP_BIN2NUM OP_DUP OP_ROT OP_1ADD OP_NUMEQUALVERIFY OP_2 OP_OUTPUTTOKENAMOUNT OP_2 OP_UTXOTOKENAMOUNT OP_2 OP_PICK OP_SUB OP_NUMEQUALVERIFY OP_3 OP_OUTPUTTOKENAMOUNT OP_NUMEQUALVERIFY OP_3 OP_OUTPUTVALUE 2003 OP_GREATERTHANOREQUAL OP_VERIFY OP_3 OP_UTXOTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_3 OP_UTXOBYTECODE OP_3 OP_SPLIT OP_NIP 14 OP_SPLIT OP_DROP OP_3 OP_OUTPUTTOKENCOMMITMENT OP_SWAP OP_3 OP_PICK OP_CAT OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_2 OP_OUTPUTTOKENCATEGORY OP_2 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_2 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_2 OP_PICK OP_EQUALVERIFY OP_2 OP_EQUALVERIFY OP_3 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_ROT OP_EQUALVERIFY OP_1 OP_EQUALVERIFY OP_4 OP_OUTPUTVALUE OP_0 OP_NUMEQUALVERIFY OP_4 OP_OUTPUTBYTECODE 6a OP_3 OP_ROLL OP_SIZE OP_DUP 4b OP_GREATERTHAN OP_IF 4c OP_SWAP OP_CAT OP_ENDIF OP_SWAP OP_CAT OP_CAT OP_EQUALVERIFY OP_TXOUTPUTCOUNT OP_6 OP_NUMEQUAL OP_IF OP_5 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF OP_DROP OP_1 OP_ELSE OP_SWAP OP_2 OP_NUMEQUALVERIFY OP_TXINPUTCOUNT OP_4 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_5 OP_LESSTHANOREQUAL OP_VERIFY OP_0 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_2 OP_UTXOBYTECODE OP_EQUALVERIFY OP_2 OP_OUTPUTBYTECODE OP_2 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_2 OP_UTXOTOKENCATEGORY OP_2 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_2 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_ROT OP_EQUALVERIFY OP_1 OP_EQUALVERIFY OP_2 OP_UTXOTOKENCOMMITMENT 14 OP_SPLIT OP_3 OP_UTXOBYTECODE OP_3 OP_SPLIT OP_NIP 14 OP_SPLIT OP_DROP OP_2 OP_OUTPUTTOKENCOMMITMENT OP_SWAP OP_ROT OP_CAT OP_EQUALVERIFY OP_2 OP_UTXOTOKENAMOUNT OP_2 OP_OUTPUTTOKENAMOUNT OP_NUMEQUALVERIFY OP_2 OP_OUTPUTVALUE OP_2 OP_UTXOVALUE 69 OP_MUL 64 OP_DIV OP_GREATERTHANOREQUAL OP_VERIFY OP_3 OP_OUTPUTBYTECODE 76a914 OP_ROT OP_CAT 88ac OP_CAT OP_EQUALVERIFY OP_3 OP_OUTPUTVALUE OP_2 OP_UTXOVALUE OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_5 OP_NUMEQUAL OP_IF OP_4 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF OP_1 OP_ENDIF OP_ENDIF",
  "source": "pragma cashscript ^0.11.0;\n\ncontract Auction(bytes registryContractScriptHash) {\n\n  function withdraw(sig signature, pubkey pk){\n    require(checkSig(signature, pk));\n  }\n\n  /**\n   * Starts a new domain registration auction\n   * @param name The name being registered.\n   * \n   * The function creates a new auction with:\n   * - Starting bid >= 0.025 BCH\n   * - Registration auction duration runs for 144 blocks (~1 day), if a new bid is made with less than 72 blocks left, the auction duration is extended by 72 blocks.\n   * - A successful registration initiations results in an auctionNFT representing the auction state:\n   *   capability: (Mutable) \n   *   category: domainCategory\n   *   tokenAmount: (Represents the registrationId)\n   *   satoshiValue: (Represents the bid amount)\n   *   commitment:   bidder's PKH(20 bytes) + name(bytes)\n   * \n   // Let the tokenAmount be the registrationId. so the mintingNFT should have amount(max mintable) and registrationId 8 bytes.\n   // When creating a new registration, it updates the registrationID and also attaches tokenAmount to the immutableNFT.\n\n\n   // At the time of penalisations the tokens can just go back to the registry contract to the authorized contract.\n   // then accumulateTokens can be called to merge the tokens.\n\n      // All the input and output conditions for inputs[0], inputs[1], outputs[0] and outputs[1] are already checked in the registry contract.\n    // Needs fewer operations with this approach as it would require this code to check 0th and 1st input and output in all other contracts.\n\n   \n   * @inputs\n   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract\n   * - Input1: Any input from this contract\n   * - Input2: Minting Counter NFT from Registry contract (Increases the registrationId by 1 in the output) \n   * - Input3: Funding UTXO\n   * \n   * @outputs\n   * - Output0: Registry Contract's immutable NFT back to the Registry contract\n   * - Output1: Input1 back to this contract without any change\n   * - Output2: Minting Counter NFT going back to the Registry contract\n   * - Output3: auctionNFT to the Registry contract\n   * - Output4: OP_RETURN output containing the name\n   * - Output5: Optional change in BCH\n   */\n  function start(bytes name){\n    require(tx.inputs.length == 4);\n    require(tx.outputs.length <= 6);\n    // Lock this contract to only be used with the registry contract.\n    require(tx.inputs[0].lockingBytecode == registryContractScriptHash);\n    require(tx.inputs[2].lockingBytecode == registryContractScriptHash);\n    require(tx.outputs[2].lockingBytecode == registryContractScriptHash);\n    require(tx.outputs[3].lockingBytecode == registryContractScriptHash);\n\n    // Registration ID increases by 1 with each transaction.\n    int prevRegistrationId = int(tx.inputs[2].nftCommitment.reverse());\n    int nextRegistrationId = int(tx.outputs[2].nftCommitment.reverse());\n    require(nextRegistrationId == prevRegistrationId + 1);\n\n    require(tx.outputs[2].tokenAmount == tx.inputs[2].tokenAmount - nextRegistrationId);\n    require(tx.outputs[3].tokenAmount == nextRegistrationId);\n\n    // Every auction begins with a base value of atleast 0.025 BCH.\n    // require(tx.outputs[3].value >= 2500000);\n    // FOR TESTS: Every auction begins with a base value of atleast 0.000008 BCH.\n    require(tx.outputs[3].value >= 800);\n    // Funding UTXO/ Bid UTXO\n    require(tx.inputs[3].tokenCategory == 0x);\n    \n    // <pkh> + name > 20 bytes\n    bytes pkh = tx.inputs[3].lockingBytecode.split(3)[1].split(20)[0];\n    require(tx.outputs[3].nftCommitment == pkh + name);\n\n    // All the token categories in the transaction should be the same.\n    bytes domainCategory = tx.outputs[0].tokenCategory.split(32)[0];\n\n    require(tx.outputs[2].tokenCategory == tx.inputs[2].tokenCategory);\n    bytes counterCategory, bytes counterCapability = tx.outputs[2].tokenCategory.split(32);\n    require(counterCategory == domainCategory);\n    require(counterCapability == 0x02); // Minting\n\n    bytes auctionCategory, bytes auctionCapability = tx.outputs[3].tokenCategory.split(32);\n    require(auctionCategory == domainCategory);\n    require(auctionCapability == 0x01); // Mutable\n\n    // Enforce an OP_RETURN output.\n    require(tx.outputs[4].value == 0);\n    require(tx.outputs[4].lockingBytecode == new LockingBytecodeNullData([name]));\n\n    if(tx.outputs.length == 6){\n      // If any change then it must be pure BCH\n      require(tx.outputs[5].tokenCategory == 0x);\n    }\n  }\n\n  /**\n   * Places a new bid on an active domain registration auction\n   * \n   * The function allows placing a new bid with:\n   * - Minimum 5% increase over previous bid\n   * - Auction is extended by 72 blocks if a new bid is placed when the auction is less than 72 blocks away from ending.\n   * - Previous bidder receives their bid amount back in the same transaction,\n   * - A successful bid updates the auctionNFT by updating the PKH and satoshiValue\n   *   capability:   Mutable\n   *   category:     DomainCategory\n   *   tokenAmount:  Represents the registrationId\n   *   satoshiValue: Represents the bid amount\n   *   commitment:   Bidder's PKH(20 bytes) + name(bytes)\n   *\n   * @inputs\n   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract\n   * - Input1: Any input from this contract\n   * - Input2: auctionNFT to the Registry contract\n   * - Input3: Funding UTXO from new bidder\n   * \n   * @outputs\n   * - Output0: Registry Contract's immutable NFT back to the Registry contract\n   * - Output1: Input1 back to this contract without any change\n   * - Output2: auctionNFT to the Registry contract\n   * - Output3: Previous bid amount returned to previous bidder\n   * - Output4: Optional change in BCH to new bidder\n   */\n  function bid(){\n    require(tx.inputs.length == 4);\n    require(tx.outputs.length <= 5);\n    // Lock this contract to only be used with the registry contract.\n    require(tx.inputs[0].lockingBytecode == registryContractScriptHash);\n    require(tx.inputs[2].lockingBytecode == registryContractScriptHash);\n    require(tx.outputs[2].lockingBytecode == tx.inputs[2].lockingBytecode);\n\n    // All the token categories in the transaction should be the same.\n    bytes domainCategory = tx.outputs[0].tokenCategory.split(32)[0];\n\n    require(tx.inputs[2].tokenCategory == tx.outputs[2].tokenCategory);\n    // The second part of the pair changes with each new bid, hence it's marked as mutable.\n    // Enforcing the structure of the pair results in predictable behaviour.\n    bytes auctionCategory, bytes auctionCapability = tx.outputs[2].tokenCategory.split(32);\n    require(auctionCategory == domainCategory);\n    require(auctionCapability == 0x01); // Mutable\n\n    bytes20 previousPKH, bytes name = tx.inputs[2].nftCommitment.split(20);\n    bytes pkh = tx.inputs[3].lockingBytecode.split(3)[1].split(20)[0];\n    require(tx.outputs[2].nftCommitment == pkh + name);\n    require(tx.inputs[2].tokenAmount == tx.outputs[2].tokenAmount);\n    require(tx.outputs[2].value >= tx.inputs[2].value * 105 / 100);\n\n    // Locking bytecode of the previous bidder\n    require(tx.outputs[3].lockingBytecode == new LockingBytecodeP2PKH(previousPKH));\n    // The amount being sent back to the previous bidder\n    require(tx.outputs[3].value == tx.inputs[2].value);\n\n    if(tx.outputs.length == 5){\n      // If any change then it must be pure BCH\n      require(tx.outputs[4].tokenCategory == 0x);\n    }\n  }\n}",
  "debug": {
    "bytecode": "5179009c63527a537aac7777675179519c63c3549c69c456a16900c75179876952c75179876952cd5179876953cd517a876952cfbc8152d2bc810079527a51939c6952d352d05279949c6953d3517a9c6953cc022003a26953ce00876953c7537f7701147f7553d2517a53797e876900d101207f7552d152ce876952d101207f517a52798769007a52876953d101207f517a527a8769007a51876954cc009c6954cd016a537a8276014ba063014c7c7e687c7e7e8769c4569c6355d100876968517767517a529c69c3549c69c455a16900c75179876952c7517a876952cd52c7876900d101207f7552ce52d1876952d101207f517a527a8769007a51876952cf01147f53c7537f7701147f7552d2517a527a7e876952d052d39c6952cc52c6016995016496a26953cd0376a914527a7e0288ac7e876953cc52c69c69c4559c6354d100876968516868",
    "sourceMap": "5:2:7:3;;;;;6:21:6:30;;:32::34;;:12::35:1;5:2:7:3;;;48::96::0;;;;;49:12:49:28;:32::33;:12:::1;:4::35;50:12:50:29:0;:33::34;:12:::1;:4::36;52:22:52:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;53:22:53:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;54:23:54:24:0;:12::41:1;:45::71:0;;:12:::1;:4::73;55:23:55:24:0;:12::41:1;:45::71:0;;:12:::1;:4::73;58:43:58:44:0;:33::59:1;:::69;:29::70;59:44:59:45:0;:33::60:1;:::70;:29::71;60:12:60:30:0;;:34::52;;:55::56;:34:::1;:12;:4::58;62:23:62:24:0;:12::37:1;:51::52:0;:41::65:1;:68::86:0;;:41:::1;:12;:4::88;63:23:63:24:0;:12::37:1;:41::59:0;;:12:::1;:4::61;68:23:68:24:0;:12::31:1;:35::38:0;:12:::1;:4::40;70:22:70:23:0;:12::38:1;:42::44:0;:12:::1;:4::46;73:26:73:27:0;:16::44:1;:51::52:0;:16::53:1;:::56;:63::65:0;:16::66:1;:::69;74:23:74:24:0;:12::39:1;:43::46:0;;:49::53;;:43:::1;:12;:4::55;77:38:77:39:0;:27::54:1;:61::63:0;:27::64:1;:::67;79:23:79:24:0;:12::39:1;:53::54:0;:43::69:1;:12;:4::71;80:64:80:65:0;:53::80:1;:87::89:0;:53::90:1;81:12:81:27:0;;:31::45;;:12:::1;:4::47;82:12:82:29:0;;:33::37;:12:::1;:4::39;84:64:84:65:0;:53::80:1;:87::89:0;:53::90:1;85:12:85:27:0;;:31::45;;:12:::1;:4::47;86:12:86:29:0;;:33::37;:12:::1;:4::39;89:23:89:24:0;:12::31:1;:35::36:0;:12:::1;:4::38;90:23:90:24:0;:12::41:1;:45::80:0;:74::78;;::::1;;;;;;;;;;;;:12::80;:4::82;92:7:92:24:0;:28::29;:7:::1;:30:95:5:0;94:25:94:26;:14::41:1;:45::47:0;:14:::1;:6::49;92:30:95:5;48:2:96:3;;;125::158::0;;;;;126:12:126:28;:32::33;:12:::1;:4::35;127:12:127:29:0;:33::34;:12:::1;:4::36;129:22:129:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;130:22:130:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;131:23:131:24:0;:12::41:1;:55::56:0;:45::73:1;:12;:4::75;134:38:134:39:0;:27::54:1;:61::63:0;:27::64:1;:::67;136:22:136:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;139:64:139:65:0;:53::80:1;:87::89:0;:53::90:1;140:12:140:27:0;;:31::45;;:12:::1;:4::47;141:12:141:29:0;;:33::37;:12:::1;:4::39;143:48:143:49:0;:38::64:1;:71::73:0;:38::74:1;144:26:144:27:0;:16::44:1;:51::52:0;:16::53:1;:::56;:63::65:0;:16::66:1;:::69;145:23:145:24:0;:12::39:1;:43::46:0;;:49::53;;:43:::1;:12;:4::55;146:22:146:23:0;:12::36:1;:51::52:0;:40::65:1;:12;:4::67;147:23:147:24:0;:12::31:1;:45::46:0;:35::53:1;:56::59:0;:35:::1;:62::65:0;:35:::1;:12;:4::67;150:23:150:24:0;:12::41:1;:45::82:0;:70::81;;:45::82:1;;;:12;:4::84;152:23:152:24:0;:12::31:1;:45::46:0;:35::53:1;:12;:4::55;154:7:154:24:0;:28::29;:7:::1;:30:157:5:0;156:25:156:26;:14::41:1;:45::47:0;:14:::1;:6::49;154:30:157:5;125:2:158:3;3:0:159:1;",
    "logs": [],
    "requires": [
      {
        "ip": 11,
        "line": 6
      },
      {
        "ip": 22,
        "line": 49
      },
      {
        "ip": 26,
        "line": 50
      },
      {
        "ip": 32,
        "line": 52
      },
      {
        "ip": 38,
        "line": 53
      },
      {
        "ip": 44,
        "line": 54
      },
      {
        "ip": 50,
        "line": 55
      },
      {
        "ip": 66,
        "line": 60
      },
      {
        "ip": 75,
        "line": 62
      },
      {
        "ip": 81,
        "line": 63
      },
      {
        "ip": 86,
        "line": 68
      },
      {
        "ip": 91,
        "line": 70
      },
      {
        "ip": 108,
        "line": 74
      },
      {
        "ip": 119,
        "line": 79
      },
      {
        "ip": 129,
        "line": 81
      },
      {
        "ip": 134,
        "line": 82
      },
      {
        "ip": 144,
        "line": 85
      },
      {
        "ip": 149,
        "line": 86
      },
      {
        "ip": 154,
        "line": 89
      },
      {
        "ip": 173,
        "line": 90
      },
      {
        "ip": 182,
        "line": 94
      },
      {
        "ip": 195,
        "line": 126
      },
      {
        "ip": 199,
        "line": 127
      },
      {
        "ip": 205,
        "line": 129
      },
      {
        "ip": 211,
        "line": 130
      },
      {
        "ip": 217,
        "line": 131
      },
      {
        "ip": 228,
        "line": 136
      },
      {
        "ip": 238,
        "line": 140
      },
      {
        "ip": 243,
        "line": 141
      },
      {
        "ip": 264,
        "line": 145
      },
      {
        "ip": 270,
        "line": 146
      },
      {
        "ip": 280,
        "line": 147
      },
      {
        "ip": 290,
        "line": 150
      },
      {
        "ip": 296,
        "line": 152
      },
      {
        "ip": 305,
        "line": 156
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.11.0-next.0"
  },
  "updatedAt": "2025-02-06T19:10:05.872Z"
}