{
  "contractName": "Bid",
  "constructorInputs": [
    {
      "name": "registryContractScriptHash",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "call",
      "inputs": []
    }
  ],
  "bytecode": "OP_TXINPUTCOUNT OP_5 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_6 OP_LESSTHANOREQUAL OP_VERIFY OP_0 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_2 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_3 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_2 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_3 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_2 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_2 OP_PICK OP_EQUALVERIFY 00 OP_EQUALVERIFY OP_3 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_ROT OP_EQUALVERIFY OP_1 OP_EQUALVERIFY OP_2 OP_UTXOTOKENCATEGORY OP_2 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_3 OP_UTXOTOKENCATEGORY OP_3 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_2 OP_UTXOTOKENCOMMITMENT OP_2 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY OP_3 OP_UTXOTOKENCOMMITMENT OP_8 OP_SPLIT OP_4 OP_SPLIT OP_4 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_4 OP_OUTPUTVALUE OP_2 OP_UTXOVALUE OP_NUMEQUALVERIFY OP_OVER OP_2 OP_UTXOTOKENCOMMITMENT OP_8 OP_SPLIT OP_DROP OP_EQUALVERIFY OP_BIN2NUM OP_TXLOCKTIME OP_2DUP OP_GREATERTHANOREQUAL OP_VERIFY OP_2DUP OP_SWAP OP_SUB 48 OP_LESSTHAN OP_IF OP_DUP 48 OP_ADD OP_ROT OP_DROP OP_SWAP OP_ENDIF OP_3 OP_OUTPUTTOKENCOMMITMENT OP_2SWAP OP_CAT OP_4 OP_UTXOBYTECODE OP_CAT OP_EQUALVERIFY OP_2 OP_OUTPUTVALUE OP_2 OP_UTXOVALUE 69 OP_MUL 64 OP_DIV OP_GREATERTHANOREQUAL OP_VERIFY OP_TXOUTPUTCOUNT OP_5 OP_NUMEQUAL OP_IF OP_4 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF OP_DROP OP_1",
  "source": "pragma cashscript ^0.11.0;\n\ncontract Bid(bytes registryContractScriptHash) {\n  /**\n   * Places a new bid on an active domain registration auction\n   * \n   * The function allows placing a new bid with:\n   * - Minimum 5% increase over previous bid\n   * - Auction is extended by 72 blocks if a new bid is placed when the auction is less than 72 blocks away from ending.\n   * - Previous bidder receives their bid amount back in the same transaction,\n   * - Uses NFT pairs to track auction state:\n   *   1. (Immutable) NFT with registrationId(8 bytes) + name(bytes) + satoshi value attached to the utxo\n   *   2. (Mutable) NFT with registrationId(8 bytes) + auctionEndBlock(4 bytes) + new bidder's lockingBytecode(25 bytes)\n   * \n   * @inputs\n   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract\n   * - Input1: Any input from this contract\n   * - Input2: RegistrationPair0 to the Registry contract\n   * - Input3: RegistrationPair1 to the Registry contract\n   * - Input4: Funding UTXO from new bidder\n   * \n   * @outputs\n   * - Output0: Registry Contract's immutable NFT back to the Registry contract\n   * - Output1: Input1 back to this contract without any change\n   * - Output2: RegistrationPair0 to the Registry contract\n   * - Output3: RegistrationPair1 to the Registry contract\n   * - Output4: Previous bid amount returned to previous bidder\n   * - Output5: Optional change in BCH to new bidder\n   */\n  function call(){\n    require(tx.inputs.length == 5);\n    require(tx.outputs.length <= 6);\n    // Lock this contract to only be used with the registry contract.\n    require(tx.inputs[0].lockingBytecode == registryContractScriptHash);\n    // All the input and output conditions for inputs[0], inputs[1], outputs[0] and outputs[1] are already checked in the registry contract.\n  \n    // New bid is placed, send the funds of the previous bid to the previous bidder.\n    // Deal with all the locking bytecode restrictions.\n    require(tx.inputs[2].lockingBytecode == registryContractScriptHash);\n    require(tx.inputs[3].lockingBytecode == registryContractScriptHash);\n    require(tx.outputs[2].lockingBytecode == registryContractScriptHash);\n    require(tx.outputs[3].lockingBytecode == registryContractScriptHash);\n\n    // All the token categories in the transaction should be the same.\n    bytes domainCategory = tx.outputs[0].tokenCategory.split(32)[0];\n\n    // Pair0 never changes, only the satoshi value changes with each new bid, hence it's capability is immutable.\n    bytes pair0Category, bytes pair0Capability = tx.outputs[2].tokenCategory.split(32);\n    require(pair0Category == domainCategory);\n    require(pair0Capability == 0x00); // Immutable\n\n    // The second part of the pair changes with each new bid, hence it's marked as mutable.\n    // Enforcing the structure of the pair results in predictable behaviour.\n    bytes pair1Category, bytes pair1Capability = tx.outputs[3].tokenCategory.split(32);\n    require(pair1Category == domainCategory);\n    require(pair1Capability == 0x01); // Mutable\n\n    require(tx.inputs[2].tokenCategory == tx.outputs[2].tokenCategory);\n    require(tx.inputs[3].tokenCategory == tx.outputs[3].tokenCategory);\n\n    // RegistrationPair0 (RegistrationAuctionId + name) should be same.\n    require(tx.inputs[2].nftCommitment == tx.outputs[2].nftCommitment);\n    bytes8 registrationAuctionId, bytes remainingBytes = tx.inputs[3].nftCommitment.split(8);\n    bytes4 registrationAuctionEndBlock, bytes previousBidderLockingBytecode = remainingBytes.split(4);\n\n    // Locking bytecode of the previous bidder\n    require(tx.outputs[4].lockingBytecode == previousBidderLockingBytecode);\n    // The amount being sent back to the previous bidder\n    require(tx.outputs[4].value == tx.inputs[2].value);\n\n    // Confirm that the Pair0 and Pair1 are from the same RegistrationAuctionId.\n    require(registrationAuctionId == tx.inputs[2].nftCommitment.split(8)[0]);\n\n    int newAuctionEndBlock = int(registrationAuctionEndBlock);\n    int locktime = int(tx.locktime);\n    // Make sure that the auction is still active.\n    require(locktime <= newAuctionEndBlock);\n    if(locktime - newAuctionEndBlock < 72) {\n      // When a new bid is placed, the auction is extended by 72 blocks.\n      newAuctionEndBlock = locktime + 72;\n    }\n      // Ensure that the second piece of the pair has the locking bytecode of the new bidder.\n    require(tx.outputs[3].nftCommitment == registrationAuctionId + bytes(newAuctionEndBlock) + tx.inputs[4].lockingBytecode);\n    // Since the funds stay in the first piece of the paur, make sure that the value is atleast 5% higher.\n    require(tx.outputs[2].value >= tx.inputs[2].value * 105 / 100);\n\n    if(tx.outputs.length == 5){\n      // If any change then it must be pure BCH\n      require(tx.outputs[4].tokenCategory == 0x);\n    }\n  }\n}\n",
  "debug": {
    "bytecode": "c3559c69c456a16900c75179876952c75179876953c75179876952cd5179876953cd517a876900d101207f7552d101207f517a52798769007a0100876953d101207f517a527a8769007a51876952ce52d1876953ce53d1876952cf52d2876953cf587f007a547f54cd517a876954cc52c69c69517952cf587f758769007a81c500795279a169007952799401489f630079014893527a757c6853d2537a537a7e54c77e876952cc52c6016995016496a269c4559c6354d1008769685177",
    "sourceMap": "31:12:31:28;:32::33;:12:::1;:4::35;32:12:32:29:0;:33::34;:12:::1;:4::36;34:22:34:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;39:22:39:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;40:22:40:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;41:23:41:24:0;:12::41:1;:45::71:0;;:12:::1;:4::73;42:23:42:24:0;:12::41:1;:45::71:0;;:12:::1;:4::73;45:38:45:39:0;:27::54:1;:61::63:0;:27::64:1;:::67;48:60:48:61:0;:49::76:1;:83::85:0;:49::86:1;49:12:49:25:0;;:29::43;;:12:::1;:4::45;50:12:50:27:0;;:31::35;:12:::1;:4::37;54:60:54:61:0;:49::76:1;:83::85:0;:49::86:1;55:12:55:25:0;;:29::43;;:12:::1;:4::45;56:12:56:27:0;;:31::35;:12:::1;:4::37;58:22:58:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;59:22:59:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;62:22:62:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;63:67:63:68:0;:57::83:1;:90::91:0;:57::92:1;64:78:64::0;;:99::100;:78::101:1;67:23:67:24:0;:12::41:1;:45::74:0;;:12:::1;:4::76;69:23:69:24:0;:12::31:1;:45::46:0;:35::53:1;:12;:4::55;72:12:72:33:0;;:47::48;:37::63:1;:70::71:0;:37::72:1;:::75;:12;:4::77;74:33:74:60:0;;:29::61:1;75:23:75:34:0;77:12:77:20;;:24::42;;:12:::1;:4::44;78:7:78:15:0;;:18::36;;:7:::1;:39::41:0;:7:::1;:43:81:5:0;80:27:80:35;;:38::40;:27:::1;:6::41;;;;78:43:81:5;83:23:83:24:0;:12::39:1;:43::64:0;;:73::91;;:43::92:1;:105::106:0;:95::123:1;:43;:12;:4::125;85:23:85:24:0;:12::31:1;:45::46:0;:35::53:1;:56::59:0;:35:::1;:62::65:0;:35:::1;:12;:4::67;87:7:87:24:0;:28::29;:7:::1;:30:90:5:0;89:25:89:26;:14::41:1;:45::47:0;:14:::1;:6::49;87:30:90:5;30:2:91:3;",
    "logs": [],
    "requires": [
      {
        "ip": 4,
        "line": 31
      },
      {
        "ip": 8,
        "line": 32
      },
      {
        "ip": 14,
        "line": 34
      },
      {
        "ip": 20,
        "line": 39
      },
      {
        "ip": 26,
        "line": 40
      },
      {
        "ip": 32,
        "line": 41
      },
      {
        "ip": 38,
        "line": 42
      },
      {
        "ip": 53,
        "line": 49
      },
      {
        "ip": 58,
        "line": 50
      },
      {
        "ip": 68,
        "line": 55
      },
      {
        "ip": 73,
        "line": 56
      },
      {
        "ip": 79,
        "line": 58
      },
      {
        "ip": 85,
        "line": 59
      },
      {
        "ip": 91,
        "line": 62
      },
      {
        "ip": 105,
        "line": 67
      },
      {
        "ip": 111,
        "line": 69
      },
      {
        "ip": 120,
        "line": 72
      },
      {
        "ip": 130,
        "line": 77
      },
      {
        "ip": 159,
        "line": 83
      },
      {
        "ip": 169,
        "line": 85
      },
      {
        "ip": 178,
        "line": 89
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.11.0-next.0"
  },
  "updatedAt": "2025-02-04T13:35:53.069Z"
}