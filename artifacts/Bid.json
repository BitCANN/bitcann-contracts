{
  "contractName": "Bid",
  "constructorInputs": [
    {
      "name": "registryContractScriptHash",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "call",
      "inputs": []
    }
  ],
  "bytecode": "OP_TXINPUTCOUNT OP_5 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_6 OP_LESSTHANOREQUAL OP_VERIFY OP_0 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_2 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_3 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_2 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_3 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_2 OP_OUTPUTTOKENCATEGORY OP_OVER OP_EQUALVERIFY OP_3 OP_OUTPUTTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_ROT OP_EQUALVERIFY OP_1 OP_EQUALVERIFY OP_2 OP_UTXOTOKENCATEGORY OP_2 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_3 OP_UTXOTOKENCATEGORY OP_3 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_2 OP_UTXOTOKENCOMMITMENT OP_2 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY OP_3 OP_UTXOTOKENCOMMITMENT OP_8 OP_SPLIT OP_4 OP_SPLIT OP_4 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_4 OP_OUTPUTVALUE OP_2 OP_UTXOVALUE OP_NUMEQUALVERIFY OP_OVER OP_2 OP_UTXOTOKENCOMMITMENT OP_8 OP_SPLIT OP_DROP OP_EQUALVERIFY OP_BIN2NUM OP_TXLOCKTIME OP_2DUP OP_GREATERTHANOREQUAL OP_VERIFY OP_2DUP OP_SWAP OP_SUB 48 OP_LESSTHAN OP_IF OP_DUP 48 OP_ADD OP_ROT OP_DROP OP_SWAP OP_ENDIF OP_3 OP_OUTPUTTOKENCOMMITMENT OP_2SWAP OP_CAT OP_4 OP_UTXOBYTECODE OP_CAT OP_EQUALVERIFY OP_2 OP_OUTPUTVALUE OP_2 OP_UTXOVALUE 69 OP_MUL 64 OP_DIV OP_GREATERTHANOREQUAL OP_VERIFY OP_TXOUTPUTCOUNT OP_5 OP_NUMEQUAL OP_IF OP_4 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF OP_DROP OP_1",
  "source": "pragma cashscript ^0.11.0;\n\ncontract Bid(bytes registryContractScriptHash) {\n  /**\n   * Places a new bid on an active domain registration auction\n   * \n   * The function allows placing a new bid with:\n   * - Minimum 5% increase over previous bid\n   * - Auction is extended by 72 blocks if a new bid is placed when the auction is less than 72 blocks away from ending.\n   * - Previous bidder receives their bid amount back in the same transaction,\n   * - Uses NFT pairs to track auction state:\n   *   1. (Immutable) NFT with registrationId(8 bytes) + name(bytes) + satoshi value attached to the utxo\n   *   2. (Mutable) NFT with registrationId(8 bytes) + auctionEndBlock(4 bytes) + new bidder's lockingBytecode(25 bytes)\n   * \n   * @inputs\n   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract\n   * - Input1: Any input from this contract\n   * - Input2: RegistrationPair0 to the Registry contract\n   * - Input3: RegistrationPair1 to the Registry contract\n   * - Input4: Funding UTXO from new bidder\n   * \n   * @outputs\n   * - Output0: Registry Contract's immutable NFT back to the Registry contract\n   * - Output1: Input1 back to this contract without any change\n   * - Output2: RegistrationPair0 to the Registry contract\n   * - Output3: RegistrationPair1 to the Registry contract\n   * - Output4: Previous bid amount returned to previous bidder\n   * - Output5: Optional change in BCH to new bidder\n   */\n  function call(){\n    require(tx.inputs.length == 5);\n    require(tx.outputs.length <= 6);\n    // Lock this contract to only be used with the registry contract.\n    require(tx.inputs[0].lockingBytecode == registryContractScriptHash);\n    // All the input and output conditions for inputs[0], inputs[1], outputs[0] and outputs[1] are already checked in the registry contract.\n  \n    // New bid is placed, send the funds of the previous bid to the previous bidder.\n    // Deal with all the locking bytecode restrictions.\n    require(tx.inputs[2].lockingBytecode == registryContractScriptHash);\n    require(tx.inputs[3].lockingBytecode == registryContractScriptHash);\n    require(tx.outputs[2].lockingBytecode == registryContractScriptHash);\n    require(tx.outputs[3].lockingBytecode == registryContractScriptHash);\n\n    // All the token categories in the transaction should be the same.\n    bytes domainCategory = tx.outputs[0].tokenCategory.split(32)[0];\n\n    // Pair0 is immutable\n    require(tx.outputs[2].tokenCategory == domainCategory);\n\n    // The second part of the pair changes with each new bid, hence it's marked as mutable.\n    // Enforcing the structure of the pair results in predictable behaviour.\n    bytes pair1Category, bytes pair1Capability = tx.outputs[3].tokenCategory.split(32);\n    require(pair1Category == domainCategory);\n    require(pair1Capability == 0x01); // Mutable\n\n    require(tx.inputs[2].tokenCategory == tx.outputs[2].tokenCategory);\n    require(tx.inputs[3].tokenCategory == tx.outputs[3].tokenCategory);\n\n    // RegistrationPair0 (RegistrationAuctionId + name) should be same.\n    require(tx.inputs[2].nftCommitment == tx.outputs[2].nftCommitment);\n    bytes8 registrationAuctionId, bytes remainingBytes = tx.inputs[3].nftCommitment.split(8);\n    bytes4 registrationAuctionEndBlock, bytes previousBidderLockingBytecode = remainingBytes.split(4);\n\n    // Locking bytecode of the previous bidder\n    require(tx.outputs[4].lockingBytecode == previousBidderLockingBytecode);\n    // The amount being sent back to the previous bidder\n    require(tx.outputs[4].value == tx.inputs[2].value);\n\n    // Confirm that the Pair0 and Pair1 are from the same RegistrationAuctionId.\n    require(registrationAuctionId == tx.inputs[2].nftCommitment.split(8)[0]);\n\n    int newAuctionEndBlock = int(registrationAuctionEndBlock);\n    int locktime = int(tx.locktime);\n    // Make sure that the auction is still active.\n    require(locktime <= newAuctionEndBlock);\n    if(locktime - newAuctionEndBlock < 72) {\n      // When a new bid is placed, the auction is extended by 72 blocks.\n      newAuctionEndBlock = locktime + 72;\n    }\n      // Ensure that the second piece of the pair has the locking bytecode of the new bidder.\n    require(tx.outputs[3].nftCommitment == registrationAuctionId + bytes(newAuctionEndBlock) + tx.inputs[4].lockingBytecode);\n    // Since the funds stay in the first piece of the paur, make sure that the value is atleast 5% higher.\n    require(tx.outputs[2].value >= tx.inputs[2].value * 105 / 100);\n\n    if(tx.outputs.length == 5){\n      // If any change then it must be pure BCH\n      require(tx.outputs[4].tokenCategory == 0x);\n    }\n  }\n}\n",
  "debug": {
    "bytecode": "c3559c69c456a16900c75179876952c75179876953c75179876952cd5179876953cd517a876900d101207f7552d15179876953d101207f517a527a8769007a51876952ce52d1876953ce53d1876952cf52d2876953cf587f007a547f54cd517a876954cc52c69c69517952cf587f758769007a81c500795279a169007952799401489f630079014893527a757c6853d2537a537a7e54c77e876952cc52c6016995016496a269c4559c6354d1008769685177",
    "sourceMap": "31:12:31:28;:32::33;:12:::1;:4::35;32:12:32:29:0;:33::34;:12:::1;:4::36;34:22:34:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;39:22:39:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;40:22:40:23:0;:12::40:1;:44::70:0;;:12:::1;:4::72;41:23:41:24:0;:12::41:1;:45::71:0;;:12:::1;:4::73;42:23:42:24:0;:12::41:1;:45::71:0;;:12:::1;:4::73;45:38:45:39:0;:27::54:1;:61::63:0;:27::64:1;:::67;48:23:48:24:0;:12::39:1;:43::57:0;;:12:::1;:4::59;52:60:52:61:0;:49::76:1;:83::85:0;:49::86:1;53:12:53:25:0;;:29::43;;:12:::1;:4::45;54:12:54:27:0;;:31::35;:12:::1;:4::37;56:22:56:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;57:22:57:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;60:22:60:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;61:67:61:68:0;:57::83:1;:90::91:0;:57::92:1;62:78:62::0;;:99::100;:78::101:1;65:23:65:24:0;:12::41:1;:45::74:0;;:12:::1;:4::76;67:23:67:24:0;:12::31:1;:45::46:0;:35::53:1;:12;:4::55;70:12:70:33:0;;:47::48;:37::63:1;:70::71:0;:37::72:1;:::75;:12;:4::77;72:33:72:60:0;;:29::61:1;73:23:73:34:0;75:12:75:20;;:24::42;;:12:::1;:4::44;76:7:76:15:0;;:18::36;;:7:::1;:39::41:0;:7:::1;:43:79:5:0;78:27:78:35;;:38::40;:27:::1;:6::41;;;;76:43:79:5;81:23:81:24:0;:12::39:1;:43::64:0;;:73::91;;:43::92:1;:105::106:0;:95::123:1;:43;:12;:4::125;83:23:83:24:0;:12::31:1;:45::46:0;:35::53:1;:56::59:0;:35:::1;:62::65:0;:35:::1;:12;:4::67;85:7:85:24:0;:28::29;:7:::1;:30:88:5:0;87:25:87:26;:14::41:1;:45::47:0;:14:::1;:6::49;85:30:88:5;30:2:89:3;",
    "logs": [],
    "requires": [
      {
        "ip": 4,
        "line": 31
      },
      {
        "ip": 8,
        "line": 32
      },
      {
        "ip": 14,
        "line": 34
      },
      {
        "ip": 20,
        "line": 39
      },
      {
        "ip": 26,
        "line": 40
      },
      {
        "ip": 32,
        "line": 41
      },
      {
        "ip": 38,
        "line": 42
      },
      {
        "ip": 49,
        "line": 48
      },
      {
        "ip": 59,
        "line": 53
      },
      {
        "ip": 64,
        "line": 54
      },
      {
        "ip": 70,
        "line": 56
      },
      {
        "ip": 76,
        "line": 57
      },
      {
        "ip": 82,
        "line": 60
      },
      {
        "ip": 96,
        "line": 65
      },
      {
        "ip": 102,
        "line": 67
      },
      {
        "ip": 111,
        "line": 70
      },
      {
        "ip": 121,
        "line": 75
      },
      {
        "ip": 150,
        "line": 81
      },
      {
        "ip": 160,
        "line": 83
      },
      {
        "ip": 169,
        "line": 87
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.11.0-next.0"
  },
  "updatedAt": "2025-02-06T08:17:56.810Z"
}