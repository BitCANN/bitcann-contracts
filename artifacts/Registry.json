{
  "contractName": "Registry",
  "constructorInputs": [
    {
      "name": "domainCategory",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "withdraw",
      "inputs": [
        {
          "name": "signature",
          "type": "sig"
        },
        {
          "name": "pk",
          "type": "pubkey"
        }
      ]
    },
    {
      "name": "call",
      "inputs": []
    }
  ],
  "bytecode": "OP_OVER OP_0 OP_NUMEQUAL OP_IF OP_2SWAP OP_SWAP OP_CHECKSIG OP_NIP OP_NIP OP_ELSE OP_SWAP OP_1 OP_NUMEQUALVERIFY OP_INPUTINDEX OP_UTXOBYTECODE OP_0 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_UTXOTOKENCATEGORY OP_0 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_0 OP_UTXOTOKENCOMMITMENT OP_0 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY OP_0 OP_UTXOVALUE OP_0 OP_OUTPUTVALUE OP_NUMEQUALVERIFY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_UTXOBYTECODE OP_0 OP_UTXOTOKENCOMMITMENT OP_EQUALVERIFY OP_1 OP_UTXOBYTECODE OP_1 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_1 OP_UTXOVALUE OP_1 OP_OUTPUTVALUE OP_NUMEQUALVERIFY OP_TXLOCKTIME 0065cd1d OP_LESSTHAN OP_ENDIF",
  "source": "pragma cashscript ^0.11.0;\n\n\ncontract Registry(bytes domainCategory) {\n\n  function withdraw(sig signature, pubkey pk){\n    require(checkSig(signature, pk));\n  }\n\n\n  /**\n   * The Registry contract serves as both a source and storage for authorized NFTs.\n   * It holds NFTs with immutable capability that share the same category as domainCategory.\n   * These NFTs contain the lockingBytecode of authorized contracts.\n   * Multiple copies of these NFTs enable parallel processing through multiple threads.\n   * \n   * The contract can only be called in conjunction with one of the authorized contracts.\n   * \n   * @note Authorized contracts and their thread counts:\n   * - RegistrationAuction:           [1 thread] (Single-threaded registration)\n   * - Bid:                           [~5 threads]\n   * - DomainFactory:                 [~5 threads]\n   * - DomainValidator:               [~5 threads]\n   * - IllegalRegistration:           [~5 threads]\n   * - RegistrationConflict:          [~5 threads]\n   * \n   * @inputs\n   * - Input0: Registry contract's immutable NFT\n   * - Input1: Authorized contract's UTXO\n   * \n   * @outputs\n   * - Output0: Registry contract's NFT returned unchanged\n   * - Output1: Authorized contract's UTXO returned unchanged\n   */\n  function call() {\n    // Registry Contract\n\n    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n    require(tx.outputs[0].lockingBytecode == selfLockingBytecode);\n    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);\n\n    // Make sure that the NFT stays with the contract.\n    require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);\n    require(tx.inputs[0].nftCommitment == tx.outputs[0].nftCommitment);\n    require(tx.inputs[0].value == tx.outputs[0].value);\n    // Just check the length of tokenCategory to be 32 as immutable NFTs do not have capability.\n    require(tx.inputs[0].tokenCategory == domainCategory);\n\n    // Script Contract (Contract Composition)\n\n    // Expect the NFT commitment that contains the lockingBytecode of the eligible contract.\n    require(tx.inputs[1].lockingBytecode == tx.inputs[0].nftCommitment);\n    // Ensure the utxo from the contract goes back to the it.\n    require(tx.inputs[1].lockingBytecode == tx.outputs[1].lockingBytecode);\n    // Ensure that the value is the same (Removes the risk of getting funds stuck by attaching them to an incorrect output)\n    require(tx.inputs[1].value == tx.outputs[1].value);\n    // Note: Since the inputs and outputs are strictly locked, there is no need to check for\n    // token category, token amount and nftCommitment for inputs[1] and outputs[1].\n\n    // Only provide support for blocks and not for MTP to reduce complexity in how nLocktime is used across different contracts.\n    require(tx.locktime < 500000000);\n\n    // With these pre-requisites met, we just need to make sure that all the contracts that are deployed are written and initialized\n    // properly, and they expect this structure and handle the inputs and outputs as expected.\n  }\n}",
  "debug": {
    "bytecode": "5179009c63527a537aac777767517a519c69c0c700cd5179876900c7517a876900ce00d1876900cf00d2876900c600cc9c6900ce517a876951c700cf876951c751cd876951c651cc9c69c5040065cd1d9f68",
    "sourceMap": "6:2:8:3;;;;;7:21:7:30;;:32::34;;:12::35:1;6:2:8:3;;;35::65::0;;;;;38:42:38:63;:32::80:1;39:23:39:24:0;:12::41:1;:45::64:0;;:12:::1;:4::66;40:22:40:23:0;:12::40:1;:44::63:0;;:12:::1;:4::65;43:22:43:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;44:22:44:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;45:22:45:23:0;:12::30:1;:45::46:0;:34::53:1;:12;:4::55;47:22:47:23:0;:12::38:1;:42::56:0;;:12:::1;:4::58;52:22:52:23:0;:12::40:1;:54::55:0;:44::70:1;:12;:4::72;54:22:54:23:0;:12::40:1;:55::56:0;:44::73:1;:12;:4::75;56:22:56:23:0;:12::30:1;:45::46:0;:34::53:1;:12;:4::55;61:12:61:23:0;:26::35;:12:::1;4:0:66:1",
    "logs": [],
    "requires": [
      {
        "ip": 11,
        "line": 7
      },
      {
        "ip": 26,
        "line": 39
      },
      {
        "ip": 32,
        "line": 40
      },
      {
        "ip": 38,
        "line": 43
      },
      {
        "ip": 44,
        "line": 44
      },
      {
        "ip": 50,
        "line": 45
      },
      {
        "ip": 56,
        "line": 47
      },
      {
        "ip": 62,
        "line": 52
      },
      {
        "ip": 68,
        "line": 54
      },
      {
        "ip": 74,
        "line": 56
      },
      {
        "ip": 78,
        "line": 61
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.11.0-next.0"
  },
  "updatedAt": "2025-02-06T08:17:56.219Z"
}