{
  "contractName": "Registry",
  "constructorInputs": [
    {
      "name": "domainCategory",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "call",
      "inputs": []
    }
  ],
  "bytecode": "OP_0 OP_UTXOBYTECODE OP_ACTIVEBYTECODE OP_EQUALVERIFY OP_0 OP_UTXOBYTECODE OP_0 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_0 OP_UTXOTOKENCATEGORY OP_0 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_0 OP_UTXOTOKENCOMMITMENT OP_0 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY OP_0 OP_UTXOVALUE OP_0 OP_OUTPUTVALUE OP_NUMEQUALVERIFY OP_0 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_SWAP OP_ROT OP_EQUALVERIFY 00 OP_EQUALVERIFY OP_1 OP_UTXOBYTECODE OP_0 OP_UTXOTOKENCOMMITMENT OP_EQUALVERIFY OP_1 OP_UTXOBYTECODE OP_1 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_1 OP_UTXOVALUE OP_1 OP_OUTPUTVALUE OP_NUMEQUALVERIFY OP_1 OP_UTXOTOKENCATEGORY 00 OP_EQUAL OP_1 OP_OUTPUTTOKENCATEGORY 00 OP_EQUAL OP_BOOLAND OP_VERIFY OP_TXLOCKTIME 0065cd1d OP_LESSTHAN",
  "source": "pragma cashscript ^0.11.0;\n\n\ncontract Registry(bytes domainCategory) {\n\n  /**\n   * This contracts acts as the source as well as storage.\n   * This contract holds authorized NFT that have the same category as the domainCategory, these NFTs are of immutable capability and contains the lockingBytecode of other contracts that are \n   * authorized as the 'genesis' of the system. Those NFTs are also duplicated to support multi-threading. for example, there can be 5 threads of 'Bid' contract so there can be 5 Bids happening at the same time.\n   * This contract can only be called as along with one of those authorized contracts.\n   * \n   * @note Existing contracts are as follows:\n   * - RegistrationAuction:           [1 thread] (Creating a registration is a single threaded operation)\n   * - Bid:                           [~10 threads]\n   * - RegistrationConflict:          [~10 threads]\n   * - ClaimDomain:                   [~10 threads]\n   * - ProveInvalidDomain:            [~10 threads]\n   * - RemoveIllegalRegistration:     [~10 threads]\n   * - RevealName:                    [~10 threads]\n   * \n   */\n  function call() {\n    // Registry Contract\n\n    // Make sure that the NFT stays with the contract.\n    require(tx.inputs[0].lockingBytecode == this.activeBytecode);\n    require(tx.inputs[0].lockingBytecode == tx.outputs[0].lockingBytecode);\n    require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);\n    require(tx.inputs[0].nftCommitment == tx.outputs[0].nftCommitment);\n    require(tx.inputs[0].value == tx.outputs[0].value);\n\n    // Make sure that the token category is the domain category and the capability is immutable.\n    bytes scriptCategory, bytes scriptCapability = tx.inputs[0].tokenCategory.split(32);\n    require(scriptCategory == domainCategory);\n    // Must be Immutable as the scriptLockingBytecode are added in the immutable NFTs.\n    require(scriptCapability == 0x00); // Immutable\n\n\n    // Script Contract (Contract Composition)\n\n    // Expect the NFT commitment that contains the lockingBytecode of the eligible contract.\n    require(tx.inputs[1].lockingBytecode == tx.inputs[0].nftCommitment);\n    // Ensure the utxo from the contract goes back to the it.\n    require(tx.inputs[1].lockingBytecode == tx.outputs[1].lockingBytecode);\n    // Ensure that the value is the same (Removes the risk of getting funds stuck by attaching them to an incorrect output)\n    require(tx.inputs[1].value == tx.outputs[1].value);\n    // Ensure only Pure BCH is used. (Do not allow for any token categoryes, Removes noise and needs less checks)\n    require(tx.inputs[1].tokenCategory == 0x00 && tx.outputs[1].tokenCategory == 0x00);\n\n    // Only provide support for blocks and not for MTP to reduce complexity in how nLocktime is used across different contracts.\n    require(tx.locktime < 500000000);\n\n    // With these pre-requisites met, we just need to make sure that all the contracts that are deployed are written and initialized\n    // properly, and they expect this structure and handle the inputs and outputs as expected.\n  }\n\n}\n",
  "debug": {
    "bytecode": "00c7c1876900c700cd876900ce00d1876900cf00d2876900c600cc9c6900ce01207f517a527a8769007a0100876951c700cf876951c751cd876951c651cc9c6951ce01008751d10100879a69c5040065cd1d9f",
    "sourceMap": "26:22:26:23;:12::40:1;:44::63:0;:12:::1;:4::65;27:22:27:23:0;:12::40:1;:55::56:0;:44::73:1;:12;:4::75;28:22:28:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;29:22:29:23:0;:12::38:1;:53::54:0;:42::69:1;:12;:4::71;30:22:30:23:0;:12::30:1;:45::46:0;:34::53:1;:12;:4::55;33:61:33:62:0;:51::77:1;:84::86:0;:51::87:1;34:12:34:26:0;;:30::44;;:12:::1;:4::46;36:12:36:28:0;;:32::36;:12:::1;:4::38;42:22:42:23:0;:12::40:1;:54::55:0;:44::70:1;:12;:4::72;44:22:44:23:0;:12::40:1;:55::56:0;:44::73:1;:12;:4::75;46:22:46:23:0;:12::30:1;:45::46:0;:34::53:1;:12;:4::55;48:22:48:23:0;:12::38:1;:42::46:0;:12:::1;:61::62:0;:50::77:1;:81::85:0;:50:::1;:12;:4::87;51:12:51:23:0;:26::35;:12:::1",
    "logs": [],
    "requires": [
      {
        "ip": 5,
        "line": 26
      },
      {
        "ip": 11,
        "line": 27
      },
      {
        "ip": 17,
        "line": 28
      },
      {
        "ip": 23,
        "line": 29
      },
      {
        "ip": 29,
        "line": 30
      },
      {
        "ip": 39,
        "line": 34
      },
      {
        "ip": 44,
        "line": 36
      },
      {
        "ip": 50,
        "line": 42
      },
      {
        "ip": 56,
        "line": 44
      },
      {
        "ip": 62,
        "line": 46
      },
      {
        "ip": 72,
        "line": 48
      },
      {
        "ip": 76,
        "line": 51
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.11.0-next.0"
  },
  "updatedAt": "2025-02-02T20:04:06.848Z"
}