pragma cashscript ^0.11.0;

contract RegistrationAuction(bytes registryContractScriptHash) {
  /**
   * Starts a new domain registration auction
   * @param name The name being registered.
   * 
   * The function creates a new auction with:
   * - Starting bid >= 0.025 BCH
   * - Registration auction duration runs for 144 blocks (~1 day), if a new bid is made with less than 72 blocks left, the auction duration is extended by 72 blocks.
   * - A successful registration initiations results in two NFT pairs representing the auction state:
   *   1. (Immutable) NFT with registrationId(8 bytes) + name(32 bytes) + satoshi value attached to the utxo
   *   2. (Mutable) NFT with registrationId(8 bytes) + auctionEndBlock(4 bytes) + bidder's lockingBytecode(25 bytes)
   * - The counter, pair and domain name all have the same token category.
   * 
   * @inputs
   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract
   * - Input1: Any input from this contract
   * - Input2: Counter NFT from Registry contract (Increases the registrationId by 1 in the output) 
   * - Input3: Funding UTXO
   * 
   * @outputs
   * - Output0: Registry Contract's immutable NFT back to the Registry contract
   * - Output1: Input1 back to this contract without any change
   * - Output2: Counter NFT going back to the Registry contract
   * - Output3: RegistrationPair0 to the Registry contract
   * - Output4: RegistrationPair1 to the Registry contract
   * - Output5: OP_RETURN output containing the name
   * - Output6: Optional change in BCH
   */
  function call(bytes name){
    require(tx.inputs.length == 4);
    require(tx.outputs.length <= 7);
    // Lock this contract to only be used with the registry contract.
    require(tx.inputs[0].lockingBytecode == registryContractScriptHash);
    // All the input and output conditions for inputs[0], inputs[1], outputs[0] and outputs[1] are already checked in the registry contract.
    // Needs fewer operations with this approach as it would require this code to check 0th and 1st input and output in all other contracts.

    // Ensure that the counter NFT is incremented by 1 with each transaction.
    int prevRegistrationId = int(tx.inputs[2].nftCommitment.reverse());
    int nextRegistrationId = int(tx.outputs[2].nftCommitment.reverse());
    require(nextRegistrationId == prevRegistrationId + 1);
  
    // Inputs[3] is the funding UTXO
    require(tx.inputs[3].tokenCategory == 0x);
    // Every auction begins with a base value of atleast 0.025 BCH.
    require(tx.outputs[3].value >= 2500000);

    // Create the first piece of the registration pair. i.e Pair0
    // Note: outputs[2] nftcommitment is the new registrationAuctionId
    require(tx.outputs[3].nftCommitment == tx.outputs[2].nftCommitment + name);

    int auctionEndBlock = tx.locktime + 144;
    
    // Create the second piece of the registration pair. i.e Pair1
    // registrationAuctionId + registrationAuctionEndBlock + lockingBytecode of the funder
    // <auctionId> + <endBlock> + <lockingBytecode> = 8 bytes + 4 bytes + 25 bytes = 37 bytes
    bytes registrationCommitment1 = tx.outputs[2].nftCommitment + bytes(auctionEndBlock) + tx.inputs[3].lockingBytecode;
    require(tx.outputs[4].nftCommitment == registrationCommitment1);

    // All the token categories in the transaction should be the same.
    bytes domainCategory = tx.outputs[0].tokenCategory.split(32)[0];

    require(tx.outputs[2].tokenCategory == tx.outputs[2].tokenCategory);
    bytes idCounterCategory, bytes idCounterCapability = tx.outputs[2].tokenCategory.split(32);
    require(idCounterCategory == domainCategory);
    require(idCounterCapability == 0x02); // Minting

    // Pair0 never changes, only the satoshi value changes with each new bid, hence it's capability is immutable.
    bytes pair0Category, bytes pair0Capability = tx.outputs[3].tokenCategory.split(32);
    require(pair0Category == domainCategory);
    require(pair0Capability == 0x00); // Immutable

    // Pair1 changes with each new bid (locking bytecode), hence it's capability is mutable.
    bytes pair1Category, bytes pair1Capability = tx.outputs[4].tokenCategory.split(32);
    require(pair1Category == domainCategory);
    require(pair1Capability == 0x01); // Mutable

    // Ensure that the Counter, Pair0 and Pair1 NFTs going to the Registration Contract.
    require(tx.inputs[2].lockingBytecode == registryContractScriptHash);
    require(tx.outputs[2].lockingBytecode == registryContractScriptHash);
    require(tx.outputs[3].lockingBytecode == registryContractScriptHash);
    require(tx.outputs[4].lockingBytecode == registryContractScriptHash);

    // Enforce an OP_RETURN output.
    require(tx.outputs[5].value == 0);
    require(tx.outputs[5].lockingBytecode == new LockingBytecodeNullData([name]));

    if(tx.outputs.length == 7){
      // If any change then it must be pure BCH
      require(tx.outputs[6].tokenCategory == 0x);
    }
  }
}