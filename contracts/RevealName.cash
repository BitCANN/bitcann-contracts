pragma cashscript ^0.11.0;

contract RevealName(bytes registryContractScriptHash) {
  /**
   * Reveals the domain name after an auction has ended, the winner must reveal the name and wait a certain amount
   * of time before the domain can be claimed. 
   * @param name The domain name being revealed
   * 
   * @inputs
   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract
   * - Input1: Any input from this contract
   * - Input2: RegistrationPair0 to the Registry contract pair (auctionId + nameHash)
   * - Input3: RegistrationPair1 to the Registry contract pair (auctionId + auctionEndBlock + bidderLockingBytecode + isNameRevealed)
   * - Input4: Funding input
   * 
   * @outputs
   * - Output0: Registry Contract's immutable NFT back to the Registry contract
   * - Output1: Input1 back to this contract without any change
   * - Output2: RegistrationPair0 to the Registry contract (unchanged)
   * - Output3: RegistrationPair1 to the Registry contract (with isNameRevealed flag set to 1)
   * - Output4: OP_RETURN output containing the revealed name
   * - Output5: Optional BCH change
   * 
   * Requirements:
   * - Auction must have ended (tx.locktime > auctionEndBlock)
   * - Name must not have been previously revealed (isNameRevealed == 0)
   * - Auction Pair NFTs, Token categories and capabilities must match expected structure
   * - Bid amount must be preserved
   */
  function call(bytes name){
    require(tx.inputs.length == 5);
    require(tx.outputs.length <= 6);
    // Lock this contract to only be used with the registry contract.
    require(tx.inputs[0].lockingBytecode == registryContractScriptHash);
    // All the input and output conditions for inputs[0], inputs[1], outputs[0] and outputs[1] are already checked in the registry contract.

    require(tx.inputs[1].tokenCategory == tx.outputs[1].tokenCategory);
    require(tx.inputs[1].value == tx.outputs[1].value);
    require(tx.inputs[1].nftCommitment == tx.outputs[1].nftCommitment);

    require(tx.inputs[2].tokenCategory == tx.outputs[2].tokenCategory);
    require(tx.inputs[2].value == tx.outputs[2].value);
    // INFO: NFT commitment will be updated by updating the isNameRevealed flag.

    // All the token categories in the transaction should be the same.
    bytes domainCategory = tx.outputs[0].tokenCategory.split(32)[0];

    bytes pair0Category, bytes pair0Capability = tx.outputs[2].tokenCategory.split(32);
    require(pair0Category == domainCategory);
    require(pair0Capability == 0x00); // Immutable

    bytes pair1Category, bytes pair1Capability = tx.outputs[3].tokenCategory.split(32);
    require(pair1Category == domainCategory);
    require(pair1Capability == 0x01); // Mutable

    // Second piece (AuctionId + lockingBytecode) should be same as the previous bid.
    bytes8 registrationAuctionIdPair0, bytes registrationNameHash = tx.inputs[2].nftCommitment.split(8);

    // Ensure that the hash256 of the name provided matches the nameHash in the pair.
    require(hash256(name) == registrationNameHash);

    // Second piece (AuctionId + lockingBytecode) should be same as the previous bid.
    bytes8 registrationAuctionIdPair1, bytes remainingBytes0 = tx.inputs[3].nftCommitment.split(8);
    bytes4 auctionEndBlock, bytes remainingBytes1 = remainingBytes0.split(4);
    bytes isNameRevealed = remainingBytes1.split(32)[1];

    // Ensure that the same pair is used
    require(registrationAuctionIdPair0 == registrationAuctionIdPair1);

    // Make sure that the auction has ended.
    require(int(tx.locktime) > int(auctionEndBlock));

    // Ensure that the name is not revealed.
    require(int(isNameRevealed) == 0);

    // Mark that the name is revealed
    require(tx.outputs[3].nftCommitment == tx.inputs[3].nftCommitment.split(37)[0] + bytes1(1));

    // Ensuring an OP_RETURN output.
    require(tx.outputs[4].value == 0);
    require(tx.outputs[4].lockingBytecode == new LockingBytecodeNullData([name]));

    if(tx.outputs.length == 6){
      require(tx.outputs[5].tokenCategory == 0x00);
    }
  }
}