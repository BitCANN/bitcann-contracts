pragma cashscript ^0.11.0;

contract Auction(int minStartingBid) {
  /**
   * Starts a new domain registration auction.
   * @param name The name being registered.
   * 
   * The function creates a new auction with:
   * - Starting bid >= `minStartingBid` BCH.
   * - A successful registration initiation results in an auctionNFT representing the auction state:
   *   - capability: (Mutable)
   *   - category: parentCategory
   *   - tokenAmount: (Represents the registrationId)
   *   - satoshiValue: (Represents the bid amount)
   *   - commitment: bidder's PKH (20 bytes) + name (bytes)
   * 
   * @inputs
   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract.
   * - Input1: Any input from this contract.
   * - Input2: Minting Counter NFT from Registry contract (Increases the registrationId by 1 in the output).
   * - Input3: Funding UTXO.
   * 
   * @outputs
   * - Output0: Registry Contract's immutable NFT back to the Registry contract.
   * - Output1: Input1 back to this contract without any change.
   * - Output2: Minting Counter NFT going back to the Registry contract.
   * - Output3: auctionNFT to the Registry contract.
   * - Output4: OP_RETURN output containing the name.
   * - Output5: Optional change in BCH.
   */
  function call(bytes name) {
    require(tx.inputs.length == 4);
    require(tx.outputs.length <= 6);

    // This contract can only be used at input1 and it should return to itself.
    require(this.activeInputIndex == 1);
    require(tx.inputs[this.activeInputIndex].lockingBytecode == tx.outputs[this.activeInputIndex].lockingBytecode);
    require(tx.outputs[this.activeInputIndex].tokenCategory == 0x);

    // Lock this contract to only be used with the registry type contract.
    bytes parentContractScriptHash = tx.inputs[0].lockingBytecode;

    // Logic
    require(tx.inputs[2].lockingBytecode == parentContractScriptHash);
    require(tx.outputs[2].lockingBytecode == parentContractScriptHash);
    require(tx.outputs[3].lockingBytecode == parentContractScriptHash);

    // Registration ID increases by 1 with each transaction.
    int prevRegistrationId = int(tx.inputs[2].nftCommitment.reverse());
    int nextRegistrationId = int(tx.outputs[2].nftCommitment.reverse());
    require(nextRegistrationId == prevRegistrationId + 1);

    require(tx.outputs[2].tokenAmount == tx.inputs[2].tokenAmount - nextRegistrationId);
    require(tx.outputs[3].tokenAmount == nextRegistrationId);

    // Every auction begins with a base value of at least minStartingBid satoshis.
    require(tx.outputs[3].value >= minStartingBid);
    // Funding UTXO/ Bid UTXO
    require(tx.inputs[3].tokenCategory == 0x);
    
    // <pkh> + name > 20 bytes
    bytes pkh = tx.inputs[3].lockingBytecode.split(3)[1].split(20)[0];
    require(tx.outputs[3].nftCommitment == pkh + name);

    // All the token categories in the transaction should be the same.
    bytes parentCategory = tx.inputs[0].tokenCategory;
    require(tx.outputs[this.activeInputIndex].tokenCategory != parentCategory);

    require(tx.outputs[2].tokenCategory == tx.inputs[2].tokenCategory);
    bytes counterCategory, bytes counterCapability = tx.outputs[2].tokenCategory.split(32);
    require(counterCategory == parentCategory);
    require(counterCapability == 0x02); // Minting

    bytes auctionCategory, bytes auctionCapability = tx.outputs[3].tokenCategory.split(32);
    require(auctionCategory == parentCategory);
    require(auctionCapability == 0x01); // Mutable

    // Enforce an OP_RETURN output.
    require(tx.outputs[4].value == 0);
    require(tx.outputs[4].lockingBytecode == new LockingBytecodeNullData([name]));

    if (tx.outputs.length == 6) {
      // If any change, then it must be pure BCH.
      require(tx.outputs[5].tokenCategory == 0x);
    }
  }
}