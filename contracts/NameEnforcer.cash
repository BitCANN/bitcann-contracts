pragma cashscript 0.11.4;

contract NameEnforcer() {
  /**
   * Proves that a name contains invalid characters, burns the auctionNFT, and takes away the funds as a reward.
   * During the entire auction, this can be called at any time by anyone.
   * 
   * Rules:
   * 1. The name must consist of only these characters:
   *    - Letters (a-z or A-Z)
   *    - Numbers (0-9)
   *    - Hyphens (-)
   *
   * @param characterNumber - Number of the character in the name that is invalid (starting from 1)
   *
   * @inputs
   * - Input0: Registry Contract's authorizedThreadNFT i.e immutable NFT with commitment that has the lockingBytecode of this contract
   * - Input1: Any input from this contract.
   * - Input2: auctionNFT from Registry Contract.
   *
   * @outputs
   * - Output0: Registry Contract's authorizedThreadNFT back to the Registry contract.
   * - Output1: Input1 back to this contract without any change.
   * - Output2: Reward to caller.
   *
   */
  function call(int characterNumber) {
    require(tx.inputs.length == 3, "Transaction: must have exactly 3 inputs");
    require(tx.outputs.length == 3, "Transaction: must have exactly 3 outputs");

    // This contract can only be used at input1 and it should return the input1 back to itself.
    require(this.activeInputIndex == 1, "Input 1: name enforcer contract UTXO must be at this index");
    require(tx.inputs[this.activeInputIndex].lockingBytecode == tx.outputs[this.activeInputIndex].lockingBytecode, "Input 1: locking bytecode must match output 1");
    // Ensure that no tokenCategory is minted here.
    require(tx.outputs[this.activeInputIndex].tokenCategory == 0x, "Output 1: must not have any token category (pure BCH only)");

    // Lock this contract to only be used with the registry type contract.
    bytes registryInputLockingBytecode = tx.inputs[0].lockingBytecode;
    require(tx.inputs[2].lockingBytecode == registryInputLockingBytecode, "Input 2: locking bytecode does not match registry input's locking bytecode");

    // All the token categories in the transaction should be the same.
    bytes registryInputCategory = tx.inputs[0].tokenCategory;

    // AuctionNFT should be mutable and of the 'nameCategory' i.e registryInputCategory
    bytes auctionCategory, bytes auctionCapability = tx.inputs[2].tokenCategory.split(32);
    require(auctionCategory == registryInputCategory, "Input 2: auction token category does not match registry");
    // Auction capability should be mutable.
    require(auctionCapability == 0x01, "Input 2: auction capability must be mutable (0x01)");

    bytes name = tx.inputs[2].nftCommitment.split(20)[1];
    bytes characterSplitBytes = name.split(characterNumber)[0];
    characterNumber = characterNumber - 1;
    bytes character = characterSplitBytes.split(characterNumber)[1];
    int charVal = int(character);

    // Character is not a hyphen.
    require(charVal != 45, "Character is a hyphen"); 
    // Character is not from a-z.
    require(!within(charVal, 97, 123), "Character is lowercase letter");
    // Character is not from A-Z.
    require(!within(charVal, 65, 91), "Character is uppercase letter");
    // Character is not from 0-9.
    require(!within(charVal, 48, 58), "Character is a digit");

    // tokenAmount from the invalid auctionNFT goes to the authorizedThreadNFT to be accumulated later
    // and merged back with the CounterNFT using the `Accumulator` Contract
    require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount + tx.inputs[2].tokenAmount, "Output 0: token amount must equal input 0 + input 2 amounts (accumulation)");

    // Pure BCH.
    require(tx.outputs[2].tokenCategory == 0x, "Output 2: reward must be pure BCH (no token category)");
  }
}