pragma cashscript ^0.11.0;

contract IllegalRegistration(bytes registryContractScriptHash, bytes domainContractPartialBytecodeHash) {
  /**
   * Penalizes illegal domain registrations by allowing anyone to burn the bid and claim the funds as reward.
   * 
   * If someone attempts to register a domain that is already owned and active (has a valid heartbeat NFT),
   * this function allows anyone to:
   * - Prove the domain is already owned by providing the heartbeat NFT
   * - Burn the illegal registration bid NFTs
   * - Claim the bid funds as a reward
   * 
   * @param domainContractPartialBytecode - Partial bytecode of the domain contract to verify ownership
   * @param name - Name being registered illegally
   * 
   * @inputs
   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract
   * - Input1: Any input from this contract
   * - Input2: Heartbeat NFT proving active domain ownership
   * - Input3: Registration NFT pair0
   * - Input4: Registration NFT pair1
   * 
   * @outputs
   * - Output0: Registry Contract's immutable NFT back to the Registry contract
   * - Output1: Input1 back to this contract without any change
   * - Output2: Heartbeat NFT back to domain contract
   * - Output3: Bid funds to caller as reward
   * 
   * Requirements:
   * - Name must match stored nameHash
   * - Heartbeat must be less than 2 years old (105120 blocks)
   * - Domain contract bytecode must match expected hash
   * - Heartbeat NFT must be from valid domain contract
   * - All NFTs must have correct categories and capabilities
   */
  function call(bytes domainContractPartialBytecode, bytes name){
    require(tx.inputs.length == 5);
    require(tx.outputs.length == 4);
    // Lock this contract to only be used with the registry contract.
    require(tx.inputs[0].lockingBytecode == registryContractScriptHash);
    // All the input and output conditions for inputs[0], inputs[1], outputs[0] and outputs[1] are already checked in the registry contract.

    // All the token categories in the transaction should be the same.
    bytes domainCategory = tx.outputs[0].tokenCategory.split(32)[0];
    // Make sure that the heartbeat NFT is from the same category and in mutable capability.
    bytes heartbeatCategory, bytes heartbeatCapability = tx.inputs[2].tokenCategory.split(32);
    require(heartbeatCategory == domainCategory);
    require(heartbeatCapability == 0x01); // Mutable
   
    // NOTICE: It does not matter if the heartbeat is already older than 2 years. If it is then is should be burned
    // As it is allowed for anyone to burn the heartbeat NFT by anyone for any Domain contract is the domain has expired.

    // Send the heartbeat NFT back to the domain contract.
    require(tx.inputs[2].nftCommitment == tx.outputs[2].nftCommitment);
    require(tx.inputs[2].lockingBytecode == tx.outputs[2].lockingBytecode);
    require(tx.inputs[2].tokenCategory == tx.outputs[2].tokenCategory);
    require(tx.inputs[2].value == tx.outputs[2].value);

    bytes nameHash = tx.inputs[3].nftCommitment.split(8)[1];
    // Make sure that the name is correct.
    require(hash256(name) == nameHash);

    bytes bytecodeHash = hash160(domainContractPartialBytecode);
    require(bytecodeHash == domainContractPartialBytecodeHash);
    // Derive the locking bytecode from the domain contract bytecode using the provided bytecode,
    // provided name and the nameHash.
    bytes domainBytecode = 0x20 + domainCategory + 0x20 + nameHash + domainContractPartialBytecode;
    bytes32 scriptHash = hash256(domainBytecode);
    bytes35 domainLockingBytecode = new LockingBytecodeP2SH32(scriptHash);

    require(tx.inputs[2].lockingBytecode == domainLockingBytecode);

    bytes pair0Category, bytes pair0Capability = tx.inputs[3].tokenCategory.split(32);
    require(pair0Category == domainCategory);
    require(pair0Capability == 0x00); // Immutable

    bytes pair1Category, bytes pair1Capability = tx.inputs[4].tokenCategory.split(32);
    require(pair1Category == domainCategory);
    require(pair1Capability == 0x01); // Mutable

    bytes registrationIdPart0 = tx.inputs[3].nftCommitment.split(8)[0];
    bytes registrationIdPart1 = tx.inputs[4].nftCommitment.split(8)[0];
    require(registrationIdPart0 == registrationIdPart1);

    bytes registrationIdHeartBeat = tx.inputs[2].nftCommitment.split(8)[0];
    // Make sure that registrationId in the heartbeat is less that the registrationId in the new auction.
    require(int(registrationIdHeartBeat) < int(registrationIdPart0));
  }
}