pragma cashscript ^0.11.0;

contract RegistrationConflict(bytes registryContractScriptHash) {
  /**
   * Resolves a conflict between two competing registration auctions for the same name
   * 
   * If any new auction is created when an auction already exists then the new auction is open for penalization.
   * Anyone can provide the proof of an active auction's existance and take away the funds from the "new" invalid auction
   * as a form of reward for keeping the system secure and predictable.
   * Therefore, it's the responsibility of the application to check for any running auctions for the same name.
   * 
   * @inputs
   * - Input0: Registry Contract's immutable NFT with commitment that has the lockingBytecode of this contract
   * - Input1: Any input from this contract
   * - Input2: Valid (earlier) auction's NFT pair0 - immutable NFT with registrationId + name
   * - Input3: Valid (earlier) auction's NFT pair1 - mutable NFT with auction state
   * - Input4: Invalid (newer) auction's NFT pair0 - immutable NFT to be removed
   * - Input5: Invalid (newer) auction's NFT pair1 - mutable NFT to be removed
   * 
   * @outputs
   * - Output0: Registry Contract's immutable NFT back to the Registry contract
   * - Output1: Input1 back to this contract without any change
   * - Output2: Valid auction's NFT pair0 preserved
   * - Output3: Valid auction's NFT pair1 preserved
   * - Output4: BCH change/reward to caller
   */
  function call() {
    require(tx.inputs.length == 6);
    require(tx.outputs.length == 5);
    // Lock this contract to only be used with the registry contract.
    require(tx.inputs[0].lockingBytecode == registryContractScriptHash);
    // All the input and output conditions for inputs[0], inputs[1], outputs[0] and outputs[1] are already checked in the registry contract.

    // INFO: It is impotrant to check the tokenCategory of all the NFTs as a malicious actor can create an NFT
    // with some other category, send it to registry contract with registrationAuctionID lower than the valid bid
    // leading to burning of valid bid NFTs.

    // All the token categories in the transaction should be the same.
    bytes domainCategory = tx.outputs[0].tokenCategory.split(32)[0];

    bytes validPair0Category, bytes validPair0Capability = tx.inputs[2].tokenCategory.split(32);
    require(validPair0Category == domainCategory);
    require(validPair0Capability == 0x00); // Immutable

    bytes validPair1Category, bytes validPair1Capability = tx.inputs[3].tokenCategory.split(32);
    require(validPair1Category == domainCategory);
    require(validPair1Capability == 0x01); // Mutable

    // 2-4 should be same, 3-5 should be same
    require(tx.inputs[2].tokenCategory == tx.inputs[4].tokenCategory);
    require(tx.inputs[3].tokenCategory == tx.inputs[5].tokenCategory);

    bytes validRegistrationAuctionIdPair0, bytes nameFromValidBid = tx.inputs[2].nftCommitment.split(8);
    bytes validRegistrationAuctionIdPair1 = tx.inputs[3].nftCommitment.split(8)[0];

    bytes invalidRegistrationAuctionIdPair0, bytes nameFromInvalidBid = tx.inputs[4].nftCommitment.split(8);
    bytes invalidRegistrationAuctionIdPair1 = tx.inputs[5].nftCommitment.split(8)[0];

    // Ensure the correct pair is being used for valid registration auction
    require(validRegistrationAuctionIdPair0 == validRegistrationAuctionIdPair1);
    // Ensure the correct pair is being used for invalid registration auction
    require(invalidRegistrationAuctionIdPair0 == invalidRegistrationAuctionIdPair1);
    // Ensure the name is the same for both auctions so they can be compared
    require(nameFromValidBid == nameFromInvalidBid);
    // Ensure the auctionId of the valid bid is less than the auctionId of the invalid bid.
    require(int(validRegistrationAuctionIdPair0) < int(invalidRegistrationAuctionIdPair0));

    // Ensure no downgrading of the NFT can happen.
    require(tx.inputs[2].tokenCategory == tx.outputs[2].tokenCategory);
    require(tx.inputs[3].tokenCategory == tx.outputs[3].tokenCategory);

    // Values for valid auction pair should be the same 
    require(tx.inputs[2].value == tx.outputs[2].value);
    require(tx.inputs[3].value == tx.outputs[3].value);
    
    // Ensure the locking bytecode is the same for all the inputs and outputs
    require(tx.inputs[2].lockingBytecode == registryContractScriptHash);    
    require(tx.inputs[3].lockingBytecode == registryContractScriptHash);
    require(tx.inputs[4].lockingBytecode == registryContractScriptHash);
    require(tx.inputs[5].lockingBytecode == registryContractScriptHash);

    require(tx.outputs[2].lockingBytecode == registryContractScriptHash);
    require(tx.outputs[3].lockingBytecode == registryContractScriptHash);

    // Reward
    require(tx.outputs[4].tokenCategory == 0x);
  }
}