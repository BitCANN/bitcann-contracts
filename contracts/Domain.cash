pragma cashscript ^0.11.0;


// INFO: It's important to mention the domainCategory here as anyone can send any utxo with matching NFT commitment and capability and create records. Hence, the
// domainCategory should be a restriction in spending and creating records.

// WARNING: Do not send the ownership NFT to the domain contract. It's like keeping the lock and key together.
// Anyone will be able to call the `renounceOwnership` function burning the ownership and making it possible for a new auction to begin.

contract Domain(bytes name, bytes32 domainCategory) {

  // // Prove that the heartbeat NFT is no longer valid and burn it. Opening this domain for new registration.
  // function proveInactivity(){
  //   // (tx.locktime - heartbeat >= 2 years);
  //   // Allow burn
  // }

  // Allow the owner to withdraw any non domainCategory utxos
  function withdrawFunds() {
    bytes heartbeatCategory = tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0];
    require(heartbeatCategory != domainCategory);

    // TODO: Add owner verification using heartbeat NFT + ownership NFT
  }

  /*
   * This allows anyone to use the auth + heartbear NFT to use it with other contracts.
   * For example: Other contracts (IllegalAuction) can prove that the domain is owned and has not been inactive for 2 years or more.
   * and that acts as a security measure to eliminate illegal auctions.
   */
  function externalUse(){
    bytes heartbeatCategory, bytes heartbeatCapability = tx.inputs[this.activeInputIndex].tokenCategory.split(32);
    require(heartbeatCategory == domainCategory);
    require(heartbeatCapability == 0x01); // Mutable

    require(tx.outputs[this.activeInputIndex].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
    require(tx.outputs[this.activeInputIndex].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory);
    require(tx.outputs[this.activeInputIndex].nftCommitment == tx.inputs[this.activeInputIndex].nftCommitment);
    require(tx.outputs[this.activeInputIndex].value == tx.inputs[this.activeInputIndex].value);
  }


  /**
   * Adds or removes a record associated with this domain
   * 
   * Records are stored in OP_RETURN outputs and can be added or removed by the domain owner.
   * To add a record, include the record data directly in the OP_RETURN output.
   * To remove a record, prefix "RM" followed by the hash of the record content in the OP_RETURN output.
   * 
   * @inputs
   * - Input0: Heartbeat NFT from this domain contract
   * - Input1: Domain ownership NFT from owner
   * - Input2: Funding UTXO
   * 
   * @outputs  
   * - Output0: Heartbeat NFT returned to this contract
   * - Output1: Domain NFT returned to owner
   * - Output2: OP_RETURN containing record data or removal hash
   * - Output3: BCH change output
   * 
   */
  function addRecord() {
    require(tx.inputs.length == 3);
    require(tx.outputs.length == 4);

    bytes activeLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    require(tx.inputs[0].lockingBytecode == activeLockingBytecode);
    require(tx.inputs[0].lockingBytecode == tx.outputs[0].lockingBytecode);

    require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);
    require(tx.inputs[1].tokenCategory == tx.outputs[1].tokenCategory);

    require(tx.inputs[1].nftCommitment == tx.outputs[1].nftCommitment);

    bytes heartbeatCategory, bytes heartbeatCapability = tx.inputs[0].tokenCategory.split(32);
    require(heartbeatCategory == domainCategory);
    require(heartbeatCapability == 0x01); // Mutable

    bytes heartbeatRegistrationId = tx.inputs[0].nftCommitment.split(8)[0];
    bytes registrationId, bytes nameFromOwnerNFT = tx.inputs[1].nftCommitment.split(8);

    require(heartbeatRegistrationId == registrationId);

    // Ensure that the NFT is verified.
    require(nameFromOwnerNFT == name);

    // TODO: FIX THIS
    // Since a new record is added, update the heartbeat.
    require(tx.outputs[0].nftCommitment == bytes(tx.locktime) + name);
    // Immutable
    require(tx.inputs[1].tokenCategory == domainCategory);

    // This enforces an OP_RETURN output.
    require(tx.outputs[2].value == 0);

    require(tx.inputs[2].tokenCategory == 0x);
    require(tx.outputs[3].tokenCategory == 0x);
  }

  /**
   * Allows domain owner to renounce ownership by burning both NFTs
   * 
   * This function enables permanent domain abandonment by:
   * - Burning both the domain ownership NFT and heartbeat NFT
   * - Returning any BCH value as change
   * - Making the domain available for re-registration
   *
   * @inputs
   * - Input0: Heartbeat NFT from domain contract
   * - Input1: Domain ownership NFT from owner
   *
   * @outputs 
   * - Output0: BCH change (if any)
   *
   * Requirements:
   * - Both NFTs must be from same registration
   * - NFTs must have correct categories and capabilities
   * - Only BCH change output allowed
   */
  function renounceOwnership(){
    require(tx.inputs.length == 2);
    require(tx.outputs.length == 1);

    bytes activeLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    require(tx.inputs[0].lockingBytecode == activeLockingBytecode);
    require(tx.outputs[0].lockingBytecode == activeLockingBytecode);

    bytes heartbeatCategory, bytes heartbeatCapability = tx.inputs[0].tokenCategory.split(32);
    require(heartbeatCategory == domainCategory);
    require(heartbeatCapability == 0x01); // Mutable

        // Pure BCH
    require(tx.outputs[0].tokenCategory == 0x);

    // Immutable ownership NFT
    require(tx.inputs[1].tokenCategory == domainCategory);

    bytes heartbeatRegistrationId = tx.inputs[0].nftCommitment.split(8)[0];
    bytes registrationId = tx.inputs[1].nftCommitment.split(8)[0];

    require(heartbeatRegistrationId == registrationId);
  }
}
