pragma cashscript ^0.11.0;

contract Domain(
  bytes4 inactivityExpiryTime,
  bytes name,
  bytes domainCategory
  ) {
  /**
   * Adds or invalidates a record associated with this domain.
   * 
   * Records are created using OP_RETURN outputs.
   * To add a record, include the record data directly in the OP_RETURN output.
   * To invalidate a record, prefix "RMV" followed by the hash of the record content in the OP_RETURN output.
   * This will signal the library/indexers to exclude the record from the valid records.
   * 
   * @inputs
   * - Input0: Internal Auth NFT
   * - Input1: Domain ownership NFT from the owner
   * - Input2: Funding UTXO (Can come from anywhere)
   * 
   * @outputs  
   * - Output0: Internal Auth NFT returned to this contract
   * - Output1: Domain NFT returned to the owner
   * - Output2: OP_RETURN containing record data or invalidation hash
   * - Output3: BCH change output
   * 
   */
  function addRecord() {
    require(tx.inputs.length == 3);
    require(tx.outputs.length == 4);

    bytes activeLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;

    require(tx.inputs[0].lockingBytecode == activeLockingBytecode);
    require(tx.outputs[0].lockingBytecode == activeLockingBytecode);

    require(tx.inputs[0].tokenCategory == domainCategory);
    require(tx.inputs[1].tokenCategory == domainCategory);
    require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);
    require(tx.inputs[1].tokenCategory == tx.outputs[1].tokenCategory);

    require(tx.inputs[0].nftCommitment == tx.outputs[0].nftCommitment);
    require(tx.inputs[1].nftCommitment == tx.outputs[1].nftCommitment);

    bytes registrationId, bytes nameFromOwnerNFT = tx.inputs[1].nftCommitment.split(8);
    require(tx.inputs[0].nftCommitment == registrationId);
    require(nameFromOwnerNFT == name);

    // This enforces an OP_RETURN output.
    require(tx.outputs[2].value == 0);
    require(tx.outputs[3].tokenCategory == 0x);
  }

  /*
   * Allows this to be attached to any transaction, primarily used by DomainOwnershipGuard
   * to and prove that the domain is owned and burn the illegal auctionNFT.
   *
   * @inputs
   * - Inputx: External Auth NFT
   *
   * @outputs
   * - outputx: External Auth NFT back to seld
   */
  function externalUse() {
    require(tx.inputs[this.activeInputIndex].nftCommitment == 0x);
    require(tx.inputs[this.activeInputIndex].tokenCategory == domainCategory);

    require(tx.outputs[this.activeInputIndex].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
    require(tx.outputs[this.activeInputIndex].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory);
    require(tx.outputs[this.activeInputIndex].nftCommitment == tx.inputs[this.activeInputIndex].nftCommitment);
    require(tx.outputs[this.activeInputIndex].value == tx.inputs[this.activeInputIndex].value);
  }

  /**
   * If the incentive system fails, i.e `DomainOwnershipGuard` or `AuctionConflictResolver` fails to prevent a
   * a owner conflict. Which means there are more than 1 owner for this domain.
   * 
   * The owner with the lowest registrationID must be the only owner for this domain.
   * To help enforce this rule, this function will allow anyone to burn both the Auth NFTs of the NEW owner.
   *
   * @inputs
   * - Input0: Valid External Auth NFT
   * - Input1: Valid Internal Auth NFT
   * - Input2: Invalid External Auth NFT
   * - Input3: Invalid Internal Auth NFT
   * - Input4: BCH input from anyone
   * 
   * @outputs  
   * - Output0: Valid External Auth NFT back to self
   * - Output1: Valid Internal Auth NFT back to self
   * - Output3: BCH change output
   */
  function resolveOwnerConflict(){
    require(tx.inputs.length == 5);
    require(tx.outputs.length == 3);

    require(tx.inputs[4].tokenCategory == 0x);
    require(tx.outputs[2].tokenCategory == 0x);

    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);
    require(tx.inputs[1].lockingBytecode == selfLockingBytecode);
    require(tx.inputs[2].lockingBytecode == selfLockingBytecode);
    require(tx.inputs[3].lockingBytecode == selfLockingBytecode);

    require(tx.outputs[0].lockingBytecode == selfLockingBytecode);
    require(tx.outputs[1].lockingBytecode == selfLockingBytecode);

    // External Auth NFTs
    require(tx.inputs[0].nftCommitment == 0x);
    require(tx.inputs[2].nftCommitment == 0x);

    // Commitments of Valid Auth NFts back to self
    require(tx.outputs[0].nftCommitment == 0x);
    require(tx.outputs[1].nftCommitment == tx.inputs[1].nftCommitment);

    // Ensure that all the token inputs and outputs have domainCategory
    require(tx.inputs[0].tokenCategory == domainCategory);
    require(tx.inputs[1].tokenCategory == domainCategory);
    require(tx.inputs[2].tokenCategory == domainCategory);
    require(tx.inputs[3].tokenCategory == domainCategory);

    require(tx.outputs[0].tokenCategory == domainCategory);
    require(tx.outputs[1].tokenCategory == domainCategory);

    require(int(tx.inputs[1].nftCommitment.reverse()) < int(tx.inputs[3].nftCommitment.reverse()));
  }

  /**
   * Allows the domain owner or anyone to burn the domain by burning AuthNFTs that control this contract.
   * 
   * - Owner can burn the AuthNFTs anytime.
   * - External party can burn the AuthNFTs when the internalAuth NFT has not been used for more than `inactivityExpiryTime`.
   *
   * @inputs
   * - Input0: External Auth NFT
   * - Input1: Internal Auth NFT
   * - Input2: Pure BCH or Domain ownership NFT from the owner
   *
   * @outputs 
   * - Output0: BCH change
   *
   */
  function burn() {
    require(tx.version == 2);

    require(tx.inputs.length == 3);
    require(tx.outputs.length == 1);

    if (tx.inputs[2].tokenCategory == 0x) {
      // If pure BCH input, then allow anyone to burn given the time limit has passed.
      // Using block-based
      require(tx.age >= 0);
      // Using block-based
      // inactivityExpiryTime = 105120 blocks = 2 years
      require(tx.inputs[1].sequenceNumber >= int(inactivityExpiryTime) && tx.inputs[3].sequenceNumber <= 4294967294);
    } else {
      // If domain ownership NFT input, then allow the owner to burn anytime.
      require(tx.inputs[2].tokenCategory == domainCategory);
      require(tx.inputs[2].nftCommitment.split(8)[0] == tx.inputs[0].nftCommitment);
    }

    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);
    require(tx.inputs[1].lockingBytecode == selfLockingBytecode);

    require(tx.inputs[0].nftCommitment == 0x);
    require(tx.inputs[0].tokenCategory == tx.inputs[1].tokenCategory);
    require(tx.inputs[0].tokenCategory == domainCategory);
    require(tx.inputs[1].tokenCategory == domainCategory);

    // Return the BCH as change.
    require(tx.outputs[0].tokenCategory == 0x);
  }
}
