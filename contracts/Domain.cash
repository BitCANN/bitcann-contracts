pragma cashscript ^0.11.0;

contract Domain(bytes name) {

  // Allow the owner to withdraw any funds but the immutable NFTs.
  function withdrawFunds() {
    require(tx.inputs[this.activeInputIndex].tokenCategory.length != 32);
  }

  /*
   * Allow this to be attached to other contracts and prove that the domain is owned.
   */
  function externalUse(){
    require(tx.inputs[this.activeInputIndex].nftCommitment == 0x);

    require(tx.outputs[this.activeInputIndex].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
    require(tx.outputs[this.activeInputIndex].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory);
    require(tx.outputs[this.activeInputIndex].nftCommitment == tx.inputs[this.activeInputIndex].nftCommitment);
    require(tx.outputs[this.activeInputIndex].value == tx.inputs[this.activeInputIndex].value);
  }


  /**
   * Adds or removes a record associated with this domain
   * 
   * Records are stored in OP_RETURN outputs and can be added or removed by the domain owner.
   * To add a record, include the record data directly in the OP_RETURN output.
   * To remove a record, prefix "RM" followed by the hash of the record content in the OP_RETURN output.
   * 
   * @inputs
   * - Input0: Internal Auth NFT
   * - Input1: Domain ownership NFT from owner
   * - Input2: Funding UTXO
   * 
   * @outputs  
   * - Output0: Internal Auth NFT returned to this contract
   * - Output1: Domain NFT returned to owner
   * - Output2: OP_RETURN containing record data or removal hash
   * - Output3: BCH change output
   * 
   */
  function addRecord() {
    require(tx.inputs.length == 3);
    require(tx.outputs.length == 4);

    bytes activeLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;

    require(tx.inputs[0].lockingBytecode == activeLockingBytecode);
    require(tx.outputs[0].lockingBytecode == activeLockingBytecode);

    require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);
    require(tx.inputs[1].tokenCategory == tx.outputs[1].tokenCategory);

    require(tx.inputs[0].nftCommitment == tx.outputs[0].nftCommitment);
    require(tx.inputs[1].nftCommitment == tx.outputs[1].nftCommitment);

    bytes registrationId, bytes nameFromOwnerNFT = tx.inputs[1].nftCommitment.split(8);
    require(tx.inputs[0].nftCommitment == registrationId);
    require(nameFromOwnerNFT == name);

    // This enforces an OP_RETURN output.
    require(tx.outputs[2].value == 0);

    require(tx.inputs[2].tokenCategory == 0x);
    require(tx.outputs[3].tokenCategory == 0x);
  }

  /**
   * Allows domain owner Or anyone to burn the domain by burning NFTs that control this contract.
   * 
   * If the internalAuth NFT has not been used for > 730 days i.e 2 years, then allow anyone to burn the domain.
   * else allow the owner to burn the domain NFTs
   *
   * @inputs
   * - Input0: Internal Auth NFT
   * - Input1: External Auth NFT
   * - Input2: Domain ownership NFT from owner (Optional)
   *
   * @outputs 
   * - Output0: BCH change
   *
   */
  function burn(){
    require(tx.inputs.length == 2 || tx.inputs.length == 3);
    require(tx.outputs.length == 1);

    if(tx.inputs.length == 2){
      // Allow anyone to burn.
      require(tx.inputs[1].sequenceNumber >= 730 days);
    }

    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);
    require(tx.inputs[1].lockingBytecode == selfLockingBytecode);

    require(tx.inputs[0].nftCommitment == 0x);
    require(tx.inputs[0].tokenCategory == tx.inputs[1].tokenCategory);

    if(tx.inputs.length == 3){
      require(tx.inputs[2].tokenCategory == tx.inputs[0].tokenCategory);
      require(tx.inputs[2].nftCommitment.split(8)[0] == tx.inputs[0].nftCommitment);
    }

    // Return the BCH as change.
    require(tx.outputs[0].tokenCategory == 0x);
  }
}
