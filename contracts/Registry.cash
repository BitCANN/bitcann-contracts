pragma cashscript ^0.11.0;


contract Registry(bytes domainCategory) {
  /**
   * The Registry contract serves as both a source and storage for authorized NFTs.
   * It holds NFTs with immutable capability that share the same category as domainCategory.
   * These NFTs contain the lockingBytecode of authorized contracts that form the core system.
   * Multiple copies of NFTs enable parallel processing through multiple threads.
   * 
   * The contract can only be called in conjunction with one of the authorized contracts.
   * 
   * @note Authorized contracts and their thread counts:
   * - RegistrationAuction:           [1 thread] (Single-threaded registration)
   * - Bid:                           [~5 threads]
   * - RegistrationConflict:          [~5 threads]
   * - DomainFactory:                 [~5 threads]
   * - ProveInvalidDomain:            [~5 threads]
   * - IllegalRegistration:           [~5 threads]
   * - RegistrationConflict:          [~5 threads]
   * - RevealName:                    [~5 threads]
   * 
   * @function call
   * Validates the transaction structure and ensures:
   * 1. Registry contract's NFT is preserved and returned
   * 2. NFT has correct domain category and immutable capability
   * 3. Authorized contract's UTXO is properly handled
   * 4. Only block-based timelocks are used (no MTP)
   * 
   * @inputs
   * - Input0: Registry contract's immutable NFT
   * - Input1: Authorized contract's UTXO
   * 
   * @outputs
   * - Output0: Registry contract's NFT returned unchanged
   * - Output1: Authorized contract's UTXO returned unchanged
   */
  function call() {
    // Registry Contract

    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    require(tx.outputs[0].lockingBytecode == selfLockingBytecode);
    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);

    // Make sure that the NFT stays with the contract.
    require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);
    require(tx.inputs[0].nftCommitment == tx.outputs[0].nftCommitment);
    require(tx.inputs[0].value == tx.outputs[0].value);

    // Make sure that the token category is the domain category and the capability is immutable.
    bytes scriptCategory, bytes scriptCapability = tx.inputs[0].tokenCategory.split(32);
    require(scriptCategory == domainCategory);
    // Must be Immutable as the scriptLockingBytecode are added in the immutable NFTs.
    require(scriptCapability == 0x00); // Immutable


    // Script Contract (Contract Composition)

    // Expect the NFT commitment that contains the lockingBytecode of the eligible contract.
    require(tx.inputs[1].lockingBytecode == tx.inputs[0].nftCommitment);
    // Ensure the utxo from the contract goes back to the it.
    require(tx.inputs[1].lockingBytecode == tx.outputs[1].lockingBytecode);
    // Ensure that the value is the same (Removes the risk of getting funds stuck by attaching them to an incorrect output)
    require(tx.inputs[1].value == tx.outputs[1].value);
    // Ensure only Pure BCH is used. (Do not allow for any token categoryes, Removes noise and needs less checks)
    require(tx.inputs[1].tokenCategory == 0x00 && tx.outputs[1].tokenCategory == 0x00);

    // Only provide support for blocks and not for MTP to reduce complexity in how nLocktime is used across different contracts.
    require(tx.locktime < 500000000);

    // With these pre-requisites met, we just need to make sure that all the contracts that are deployed are written and initialized
    // properly, and they expect this structure and handle the inputs and outputs as expected.
  }
}