pragma cashscript ^0.11.0;

/**
  * @param domainCategory - The category of the domain NFTs that are authorized to be registered. [In reverse order]
 */
contract Registry(bytes domainCategory) {
  /**
   * The Registry contract serves as both a source and storage for authorized NFTs.
   * It holds NFTs with immutable capability that share the same category as domainCategory.
   * These NFTs contain the lockingBytecode of authorized contracts.
   * Multiple copies of these NFTs enable parallel processing through multiple threads.
   * 
   * The contract can only be called in conjunction with one of the authorized contracts.
   * 
   * @note Authorized contracts and their thread counts:
   * - Auction:           [1 thread] (Single-threaded registration)
   * - DomainFactory:                 [~5 threads]
   * - DomainNameShield:              [~5 threads]
   * - IllegalRegistration:           [~5 threads]
   * - RegistrationConflict:          [~5 threads]
   * 
   * @inputs
   * - Input0: Registry contract's immutable NFT
   * - Input1: Authorized contract's UTXO
   * 
   * @outputs
   * - Output0: Registry contract's NFT returned unchanged
   * - Output1: Authorized contract's UTXO returned unchanged
   */
  function call() {
    // Registry Contract

    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);
    require(tx.outputs[0].lockingBytecode == selfLockingBytecode);

    // Make sure that the NFT stays with the contract.
    require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);
    require(tx.inputs[0].nftCommitment == tx.outputs[0].nftCommitment);
    require(tx.inputs[0].value == tx.outputs[0].value);
    // Just check the length of tokenCategory to be 32 as immutable NFTs do not have capability.
    require(tx.inputs[0].tokenCategory == domainCategory);
    // Note: Not checking the tokenAmount as it changes.

    // Authorized Contract

    // Expect the NFT commitment that contains the lockingBytecode of the authorized contract.
    require(tx.inputs[1].lockingBytecode == tx.inputs[0].nftCommitment);
    // With these pre-requisites met, we just need to make sure that all the contracts that are deployed are written and initialized
    // properly, and they expect this structure and handle the inputs and outputs as expected.
  }


  // /**
  //  * @inputs
  //  * - Input0: Minting NFT + tokenAmount0
  //  * - Input1: Authorized contract's UTXO + tokenAmount1
  //  * 
  //  * @outputs
  //  * - Output0: Minting NFT back to the Registry contract + tokenAmount (tokenAmount0 + tokenAmount1)
  //  * - Output1: Authorized contract's UTXO back to the Registry contract
  //  * - Output2: Change BCH
  //  */
  // function accumulateTokens(){
  //   // require(tx.inputs.length == 2);
  //   // require(tx.outputs.length == 3);

  //   // TEMP
  //   require(tx.inputs.length >= 1);
  //   require(tx.outputs.length >= 1);
  // }
}
