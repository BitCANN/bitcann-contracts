pragma cashscript ^0.11.0;


contract Registry(bytes domainCategory) {

  /**
   * This contracts acts as the source as well as storage.
   * This contract holds authorized NFT that have the same category as the domainCategory, these NFTs are of immutable capability and contains the lockingBytecode of other contracts that are 
   * authorized as the 'genesis' of the system. Those NFTs are also duplicated to support multi-threading. for example, there can be 5 threads of 'Bid' contract so there can be 5 Bids happening at the same time.
   * This contract can only be called as along with one of those authorized contracts.
   * 
   * @note Existing contracts are as follows:
   * - RegistrationAuction:           [1 thread] (Creating a registration is a single threaded operation)
   * - Bid:                           [~10 threads]
   * - RegistrationConflict:          [~10 threads]
   * - ClaimDomain:                   [~10 threads]
   * - ProveInvalidDomain:            [~10 threads]
   * - RemoveIllegalRegistration:     [~10 threads]
   * - RevealName:                    [~10 threads]
   * 
   */
  function call() {
    // Registry Contract

    // Make sure that the NFT stays with the contract.
    require(tx.inputs[0].lockingBytecode == this.activeBytecode);
    require(tx.inputs[0].lockingBytecode == tx.outputs[0].lockingBytecode);
    require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);
    require(tx.inputs[0].nftCommitment == tx.outputs[0].nftCommitment);
    require(tx.inputs[0].value == tx.outputs[0].value);

    // Make sure that the token category is the domain category and the capability is immutable.
    bytes scriptCategory, bytes scriptCapability = tx.inputs[0].tokenCategory.split(32);
    require(scriptCategory == domainCategory);
    // Must be Immutable as the scriptLockingBytecode are added in the immutable NFTs.
    require(scriptCapability == 0x00); // Immutable


    // Script Contract (Contract Composition)

    // Expect the NFT commitment that contains the lockingBytecode of the eligible contract.
    require(tx.inputs[1].lockingBytecode == tx.inputs[0].nftCommitment);
    // Ensure the utxo from the contract goes back to the it.
    require(tx.inputs[1].lockingBytecode == tx.outputs[1].lockingBytecode);
    // Ensure that the value is the same (Removes the risk of getting funds stuck by attaching them to an incorrect output)
    require(tx.inputs[1].value == tx.outputs[1].value);
    // Ensure only Pure BCH is used. (Do not allow for any token categoryes, Removes noise and needs less checks)
    require(tx.inputs[1].tokenCategory == 0x00 && tx.outputs[1].tokenCategory == 0x00);

    // Only provide support for blocks and not for MTP to reduce complexity in how locking is used across different contracts.
    require(tx.locktime < 500000000);

    // With these pre-requisites met, we just need to make sure that all the contracts that are deployed are written and initialized
    // properly, and they expect this structure and handle the inputs and outputs as expected.
  }

}
