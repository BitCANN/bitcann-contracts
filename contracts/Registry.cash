pragma cashscript ^0.11.0;


contract Registry(bytes domainCategory) {

  function withdraw(sig signature, pubkey pk){
    require(checkSig(signature, pk));
  }


  /**
   * The Registry contract serves as both a source and storage for authorized NFTs.
   * It holds NFTs with immutable capability that share the same category as domainCategory.
   * These NFTs contain the lockingBytecode of authorized contracts.
   * Multiple copies of these NFTs enable parallel processing through multiple threads.
   * 
   * The contract can only be called in conjunction with one of the authorized contracts.
   * 
   * @note Authorized contracts and their thread counts:
   * - RegistrationAuction:           [1 thread] (Single-threaded registration)
   * - Bid:                           [~5 threads]
   * - DomainFactory:                 [~5 threads]
   * - DomainValidator:               [~5 threads]
   * - IllegalRegistration:           [~5 threads]
   * - RegistrationConflict:          [~5 threads]
   * 
   * @inputs
   * - Input0: Registry contract's immutable NFT
   * - Input1: Authorized contract's UTXO
   * 
   * @outputs
   * - Output0: Registry contract's NFT returned unchanged
   * - Output1: Authorized contract's UTXO returned unchanged
   */
  function call() {
    // Registry Contract

    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    require(tx.outputs[0].lockingBytecode == selfLockingBytecode);
    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);

    // Make sure that the NFT stays with the contract.
    require(tx.inputs[0].tokenCategory == tx.outputs[0].tokenCategory);
    require(tx.inputs[0].nftCommitment == tx.outputs[0].nftCommitment);
    require(tx.inputs[0].value == tx.outputs[0].value);
    // Just check the length of tokenCategory to be 32 as immutable NFTs do not have capability.
    require(tx.inputs[0].tokenCategory == domainCategory);

    // Script Contract (Contract Composition)

    // Expect the NFT commitment that contains the lockingBytecode of the eligible contract.
    require(tx.inputs[1].lockingBytecode == tx.inputs[0].nftCommitment);
    // Ensure the utxo from the contract goes back to the it.
    require(tx.inputs[1].lockingBytecode == tx.outputs[1].lockingBytecode);
    // Ensure that the value is the same (Removes the risk of getting funds stuck by attaching them to an incorrect output)
    require(tx.inputs[1].value == tx.outputs[1].value);
    // Note: Since the inputs and outputs are strictly locked, there is no need to check for
    // token category, token amount and nftCommitment for inputs[1] and outputs[1].

    // Only provide support for blocks and not for MTP to reduce complexity in how nLocktime is used across different contracts.
    require(tx.locktime < 500000000);

    // With these pre-requisites met, we just need to make sure that all the contracts that are deployed are written and initialized
    // properly, and they expect this structure and handle the inputs and outputs as expected.
  }
}